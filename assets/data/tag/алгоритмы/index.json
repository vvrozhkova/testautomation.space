{"hash":"17b62eb9524b8c425ab29f45bac198452a2ffcf4","data":{"tag":{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/","belongsTo":{"totalCount":10,"pageInfo":{"totalPages":1,"currentPage":1},"edges":[{"node":{"id":"8a6b33e55a7ca748d1b9e12020f95b24","title":"Алгоритмы (курс Яндекс)","content":"\n1. [Сложность, тестирование, особые случаи](/slozhnost-testirovanie-osobye-sluchai/)\n2. [Линейный поиск](/linejnyj-poisk/)\n3. [Множества](/mnozhestva/)\n4. [Словари и сортировка подсчётом](/slovari-i-sortirovka-podschyotom/)\n5. [Префиксные суммы и два указателя](/prefiksnye-summy-i-dva-ukazatelya/)\n6. [Бинарный поиск](/binarnyj-poisk/)\n7. [Сортировка событий](/sortirovka-sobytij/)\n8. [Деревья](/derevya/)\n\nhttps://www.youtube.com/playlist?list=PL6Wui14DvQPySdPv5NUqV3i8sDbHkCKC5\n\n\n","date":"2022-07-24T00:00:00.000Z","path":"/algoritmy-kurs-yandeks/","icon":"fas fa-code","image":"null","order":1,"category":{"title":"java","path":"/category/java/"},"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[]}},{"node":{"id":"6eb2710fac45f4b875e8f37a1c0d5eaf","title":"Сложность, тестирование, особые случаи","content":"\n## Сложность\n\nДля тренировки нужно написать 10000 строк кода.\nДля этого можно использовать сайты leetcode.com, codeforces.com\n\n**Сложность алгоритма** - это порядок количества действий, которые выполняет алгоритм.\n\nЕсли сложность $O(N)$ - это значит, что скорость алгоритма зависит напрямую от количества данных и такую сложность называют **линейной**. \nНапример, обычный цикл от $1$ до $N$.\n\nЕсли в программе два вложенных цикла, каждый от $1$ до $N$, тогда сложность составит $O(N^2)$.\n\n$O$ никак не зависит от константы.  \n$100*N = O(N), 2*N=O(N)$. Здесь 2 и 100 - константы, не зависящие от размера входных данных.  Константы не так сильно влияют на скорость алгоритма при больших параметрах.\n\nНапример, алгоритм, который работает за $O(100*N)$ будет работать лучше, чем $O(1*N^2)$, поэтому константа не так принципиальна.\n\nТ.е. если в алгоритме выполняется цикл, то не важно сколько действий выполняется внутри цикла, важно сколько вхождений выполнится.\n\n$O$(O-большое) означает, что наш алгоритм работает не более, чем за столько действий сколько указано в скобках, например $O(N) = 10 * N$ - означает что найдется такое число, в нашем случае 10, что наш алгоритм гарантировано совершит не больше, чем 10 * N  действий. Чем асимптотическая сложность ниже, тем лучше, тем быстрее решается.\n\nСравнение алгоритмов по асимптотической сложности имеет смысл проводить только для больших значений параметров, пока он маленький там может произойти, что угодно :). \n\nЕще существует **\"пространственная сложность\"** - количество использованной памяти, сколькдополнительной памяти потребляет наш алгоритм.\nПамяти алгортим не может потребить больше чем он потратил времяБ потому что чтобы что то положить в ячейку памяти это тоже элементарная операция. \nНо иногда алгоритмы отличаются и по дополнительной памяти которую они употребляют. \n\n### Задача №1. Условие.\nДана строка в кодировке UTF-8.  \nНайти самый часто встречающийся в ней символ. Если несколько символов встречаются одинаково часто, то можно вывести любой.\n\n### Задача №1. Решение 1.\n\nПереберем все позиции и для каждой позиции в строке еще раз переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.\n\n--- \n\nЗаводим внешние переменные для максимального количества повторений и для значения символа. \n\nВнешний цикл сначала выбирает первый символ и далее проходит по строке и ищет сколько раз этот символ в ней встречается, запоминаем значение символа и количество повторений и сохраняем их во внешнюю переменную. \n\nЗатем переходим ко второму символу и также проверяем сколько раз он встретился, если количество его повторений больше, чем во внешней переменной, то обновляем значения для максимального количества повторений и для значения символа во внешних переменных и так далее до конца строки.\n\n**_Сложность алгоритма: _**$O(N^2)$, тк 2 вложенных цикла.\n\n```java\npublic static char maxRepeatableChar(String s) {\n    int ansCount = 0;\n    char ans = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        char nowChar = s.charAt(i);\n        int nowCount = 0;\n\n        for (int j = 0; j < s.length(); j++) {\n            if (s.charAt(j) == nowChar) {\n                nowCount += 1;\n            }\n        }\n\n        if (nowCount > ansCount) {\n            ansCount = nowCount;\n            ans = nowChar;\n        }\n    }\n    return ans;\n}\n```\n\nНо есть более эффективное решение. \n\n### Задача №1. Решение 2.\n\nПереберем все символы, встречающиеся в строке, а затем переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.\n\n---\n\nПолучаем список уникальных букв через Set. \n\nПроходим по нему в цикле и для каждой из букв запускаем цикл, который подсчитывает количество повторений для этой буквы. \n\nЗаписываем в счетчик и возвращаем искомый символ.\n\n**_Сложность алгоритма: _**$O(N*K)$, где K - количество уникальных букв, цикл по ним чтобы узнать, сколько каждая из них встречалась раз, N - общее количество букв, цикл по N, чтобы найти количество повторений для каждой из уникальных букв.\n\n```java\npublic static char maxRepeatableChar(String s) {\n    Set<Character> str = s.chars().mapToObj(e -> (char) e).collect(Collectors.toSet());\n\n    char ans = 0;\n    int ansCount = 0;\n\n    for (Character now : str) {\n        int nowCount = 0;\n        for (int j = 0; j < s.length(); j++) {\n            if (s.charAt(j) == now) {\n                nowCount += 1;\n            }\n        }\n        if (nowCount > ansCount) {\n            ansCount = nowCount;\n            ans = now;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Задача №1. Решение 3.\n\nЗаведем словарь, где ключом является символ, а значением - сколько раз он встретился. \n\nПроходим в цикле по всем символам строки и если символ встретился впервые - создаем элемент словаря с ключом, совпадающим с этим символом и значением ноль. Далее для текущего символа в словаре прибавляем к элементу словаря с ключом, совпадающим с этим символом единицу. \n\nПосле выполнения прохода по всем символам, запускаем цикл прохода по ключам словаря и сравниваем значение по ключу с текущим максимальным повторением, если значение больше то переписываем символ в ответе и макимальное количество повторений.\n\n**_Сложность алгоритма: _**$O(N + K) = O(N)$, N - количество проходов пока формировали словарь, K - количество прохода только по (уникальным) ключам. Но так как K обычно меньше N то можно сказать что алгоритм выполняется за $O(N)$.\n\n```java\npublic static char maxRepeatableChar(String s) {\n    char ans = 0;\n    int ansCount = 0;\n    Map<Character, Integer> dict = new HashMap<>();\n\n    for (int i = 0; i < s.length(); i++) {\n        char now = s.charAt(i);\n        if (!dict.containsKey(now)) {\n            dict.put(now, 0);\n        }\n        dict.put(now, dict.get(now) + 1);\n    }\n\n    for (Character key : dict.keySet()) {\n        if (dict.get(key) > ansCount) {\n            ansCount = dict.get(key);\n            ans = key;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Сравниваем затраченное время и память (дополнительную)\n\n|Решение|Время|Память|\n|---|---|---|\n|#1 Проход по строке для каждого символа|$O(N^2)$|$O(N)$ - так как храним только саму строку|\n|#2 Проход по строке для каждого символа в множестве|$O(N*K)$|$O(N+K) = O(N)$ - храним строку и множество ($K$)|\n|#3 Использование словаря|$O(N)$|$O(K)$ - храним только словарь из K элементов|\n\n## Особые случаи\n\n### Сумма последовательности\n\nВ данном алгоритме не обязательно делать проверку на пустую строку так как и без этой проверки у нас выведется ноль.\n\n```java\npublic static int sequenceSum(String s) {\n    int[] sequence = s.chars().toArray();\n    int sequenceSum = 0;\n    for (int i = 0; i < sequence.length; i++) {\n        sequenceSum += sequence[i];\n    }\n    \n    return sequenceSum;\n}\n```\n\n### Максимум последовательности\n\nВ этом алгоритме мы не можем задать начальное значение нулем, тк в массиве могут быть еще и отрицательные значения, поэтому необходимо добавить ночальную проверку на пустую строку и при выполнении алгоритма стартовому значению присвоить первое значение в массиве.\n\n```java\npublic static double sequenceMax(String s) {\n    int[] sequence = s.chars().toArray();\n    if (sequence.length == 0) {\n        return Double.NEGATIVE_INFINITY;\n    } else {\n        int sequenceMax = sequence[0];\n        for (int i = 0; i < sequence.length; i++) {\n            if (sequence[i] > sequenceMax) {\n                sequenceMax = sequence[i];\n            }\n        }\n        return sequenceMax;\n    }\n}\n```\n\n## Тестирование\n\nПри тестировании алгоритма нужно проверить:\n\n- тесты из условия (если есть)\n- общие случаи\n- особые случаи (все числа отрицательные, пустая последовательность)\n\nТесты для алгоритма на поиск максимума последовательности:\n\n- 1 3 2 - общий случай (максимум в середине)\n- 1 2 3, 3 2 1 - максимум по краям \n- 1 1 1 - все элементы одинаковы\n- 1 - один элемент\n- _ - пустая последовательность\n- -2 -1 -3 - все числа отрицательные\n\n### Советы по составлению тестов\n\n- Если есть примеры - реши их руками и сверь ответ. Если не совпадает, то либо правильных ответов может быть несколько, либо ты неправильно понял задачу;\n- Сначала составь несколько примеров и реши задачу руками, чтобы лучше понять условие и чтобы потом было с чем сравнить;\n- Проверь последовательность из одного элемента и пустую последовательность;\n- \"Краевые эффекты\" - проверь что программа работает корректно в начале и конце последовательности сделай тесты чтоы ответ находился на первом и на последнем месте последовательности;\n- Составь покрытие всех ветвлений, так чтобы был тест, который входит в каждый if и else;\n- Подбери тесты чтобы не было ни одного входа в цикл;\n- Один тест - одна возможная ошибка;\n\n## Вопросы\n\n1. **_Что приоритетней оптимизация по памяти или по времени исполнения?_**\n\nЧаще всего по времени исполнения, а если есть несколько алгориитмов с одинаковым временем то уже по памяти.\nНо бывают редкие задачи, где память играет решающее значение.\n\n2. **_Почему в решение №3 мы использовали Set но не считали его асимптотическую сложность?_**\n\nДобавление в Set происходит за $O(1)$ времени. Объяснение будет в следующих лекциях.\n\n3. **_Как проверить алгоритм, если не знаешь где может быть ошибка?_**\n\n    1. пишем самый простой базовый алгоритм для решения задачи\n    2. пишем генератор маленьких массивов из случайных чисел\n    3. запускаем цикл и сравниваем ответ нашего алгоритма с ответом примитивного алгоритма","date":"2022-07-24T00:00:00.000Z","path":"/slozhnost-testirovanie-osobye-sluchai/","icon":"fas fa-code","image":"null","order":2,"category":null,"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[{"value":"Сложность","anchor":"#сложность"},{"value":"Особые случаи","anchor":"#особые-случаи"},{"value":"Тестирование","anchor":"#тестирование"},{"value":"Вопросы","anchor":"#вопросы"}]}},{"node":{"id":"9916f091823ac5e3105f733f94759092","title":"Сортировки. Быстрая, слиянием и поразрядная","content":"\n## Быстрая сортировка. Quick sort","date":"2023-11-19T00:00:00.000Z","path":"/sortirovki-bystraya-sliyaniem-i-porazryadnaya/","icon":"fas fa-code","image":"null","order":2,"category":null,"tags":[{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"},{"title":"сортировки","path":"/tag/%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8/"},{"title":"быстрая сортировка","path":"/tag/%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F%20%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/"},{"title":"сортировка слиянием","path":"/tag/%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0%20%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC/"},{"title":"поразрядная сортировка","path":"/tag/%D0%BF%D0%BE%D1%80%D0%B0%D0%B7%D1%80%D1%8F%D0%B4%D0%BD%D0%B0%D1%8F%20%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0/"}],"headings":[{"value":"Быстрая сортировка. Quick sort","anchor":"#быстрая-сортировка-quick-sort"}]}},{"node":{"id":"11e057dfa368eb6b8d0d3f8135876333","title":"Линейный поиск","content":"\n## Классические задачи линейного поиска\n\nЛинейный поиск - способ поиска, когда перебираются все элементы.\n\nСложность линейного поиска - линейная, т.е. $O(N)$.\n\nОбычно ищут \"подходящий\" элемент или \"наиболее подходящий элемент\".\n\n### Задача 1. Найти первое вхождение положительного числа.\n\nДана последовательность чисел длиной N. Найти первое (левое) вхождение положительного числа X в нее или вывести -1, если число X не встречалось.\n\nРешение:\n\nСначала положим в ответ -1, затем будем перебирать все элементы. Если текущий элемент равен X и ответ равен -1, запишем в ответ текущую позицию.\n\n```java\npublic static int findx(int[] seq, int x) {\n    int ans = -1;\n    for (int i = 0; i < seq.length; i++) {\n        if (ans == -1 && seq[i] == x) {\n            ans = i;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Задача 2. Найти последнее вхождение положительного числа.\n\nДана последовательность чисел длиной N. Найти последнее (правое) вхождение положительного числа X в неё или вывести -1, если число X не встречалось.\n\nРешение:\n\nСначала положим в ответ -1, затем будем перебирать все элементы. Если текущий элемент равен X - запишем в ответ текущую позицию (без проверки что текущая позиция равна -1).\n\n```java\npublic static int findx(int[] seq, int x) {\n    int ans = -1;\n    for (int i = 0; i < seq.length; i++) {\n        if (seq[i] == x) {\n            ans = i;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Задача 3. Найти максимальное число в последовательности.\nДана последовательность чисел длиной N (N>0). Найти максимальное число в последовательности.\n\nРешение:\n\nСначала положим в ответ нулевой элемент последовательности (он точно существует, тк N>0), затем будем перебирать все элементы. Если текущий элемент больше ответа - запишем в ответ текущий элемент.\n\n```java\npublic static int findMax(int[] seq) {\n    int ans = seq[0];\n    for (int i = 1; i < seq.length; i++) {\n        if (seq[i] > ans) {\n            ans = seq[i];\n        }\n    }\n\n    return ans;\n}\n```\n\nЕсли условие допускает пустую последовательность то этот случай нужно обрабатывать отдельно через if.\n\nСтроки сравниваются по символьно и когда символы начинают отличаться можно сказать какая строка меньше или больше. Если строки длинные то сравнение будет идти долго, время равно длине строки. \n\nЛексикографический порядок - это сравнение с учетом регистра.\nАлфавитный порядок - это сравннеие, как в словаре, без учета регистра.\n\nРешение задачи не подойдет для строк, так как будет постоянно перезаписываться значение ans, а для строк это требует больше времени, строки могут быть длинные.\n\nНужно запоминать не значение, а индекс максимального элемента. \n\n```java\npublic static String findMax(String[] seq) {\n    int ans = 0;\n    for (int i = 1; i < seq.length; i++) {\n        if (seq[i].compareTo(seq[ans]) == 0) {\n            ans = i;\n        }\n    }\n\n    return seq[ans];\n}\n```\n\n### Задача 4. Найти максимальное число в последовательности и второе по величине число.\nДана последовательность чисел длиной N (N>1). \nНайти максимальное число в последовательности и второе по величине число (такое, которое будет максимальным, если вычеркнуть из последовательности одно максимальное число).\n\nРешение:\n\nЗаведем две переменные для первого и второго максимума. Возьмем первые два числа из последовательности и запишем большее из них в переменную для первого макисмума, а меньшее - для второго. Пройдем по всей последовательности. Если очередное число больше первого максимума, то запишем во второй макисмум значение первого, а в первый - текущее число. Если только больше второго, запишем текущее число во второй макисмум.\n\n```java\npublic static int[] findMax2(int[] seq) {\n        int max1, max2;\n        if (seq[0] > seq[1]) {\n            max1 = seq[0];\n            max2 = seq[1];\n        } else {\n            max1 = seq[1];\n            max2 = seq[0];\n        }\n        for (int i = 2; i < seq.length; i++) {\n            if (seq[i] > max1) {\n                max2 = max1;\n                max1 = seq[i];\n            } else if (seq[i] > max2) {\n                max2 = seq[i];\n            }\n        }\n        return new int[]{max1, max2};\n    }\n```\n\n### Задача 5. Найти минимальное четное число в последовательности.\nДана последовательность чисел длиной N. Найти минимальное четное число в последовательности или вывести -1, если такого не существует.\n\nРешение:\n\nВ переменную для ответа положим -1. Если очередное число четное, а ответ равен -1 или ответ больше текущего числа, то запишем в ответ текущее число.\n\nУниверсальный способ для решения это завести boolean переменную с признаком встречали ли мы четное число или нет. Изначально она равна fasle, а как встретили четное число делаем ее true.\n\n```java\npublic static int findMinEven(int[] seq) {\n    int ans = 0;\n    boolean isFound = false;\n\n    for (int i = 0; i < seq.length; i++) {\n        int now = seq[i];\n        if (now % 2 == 0 && (!isFound || now < ans)) {\n            ans = now;\n            isFound = true;\n        }\n    }\n    return ans;\n}\n```\n\n## Два прохода\n\n### Задача 6. Вывести все самые короткие слова через пробел.\n\nДана последовательность слов. Вывести все самые короткие слова через пробел.\n\nЕсли решать задачу за один проход, то есть сохранять количество символов в строке и саму строку и при нахождении еще более меньшей обновлять ее, это будет медленно и будет лишняя память заниматься. Так как мы будем накапливать слова, и хороше если добавление слова будет занимать $O(1)$, но может быть и больше, если копировать сами объекты. В Java лучше использовать для этих целей StringBuilder или StringBuffer.\n\n```java\npublic static String shortWords(String[] words) {\n    int minLength = words[0].length();\n    for (String word : words) {\n        if (word.length() < minLength) {\n            minLength = word.length();\n        }\n    }\n\n    StringBuilder ans = new StringBuilder();\n    for (String word : words) {\n        if (word.length() == minLength) {\n            ans.append(word).append(\" \");\n        }\n    }\n\n    return ans.toString();\n}\n```\n\n### Задача 7. Определить, сколько блоков воды осталось после дождя в низинах острова.\n\nИгра PitCraft происходит в двумерном мире, который состоит из блоков размером 1 на 1 метр. Остров игрока представляет собой набор столбцов различной высоты, состоящий из блоков камня и окруженный морем. Над островом прошел сильный дождь, который затопил водой все низины, а не поместившаяся в них вода стекла в море, не увеличив его уровень.\n\nПо ландшафту острова определить, скоолько блоков воды осталось после дождя в низинах острова.\n\n**_Решение:_**\n\nПосле того как вода нальется наш остров примет форму ступенек. Давайте найдем самый высокий столбик(вершину) и до этой вершины будут ступеньки на подъем, вся вода будет сливаться влево от вершины, а все что справа от вершины будет утекать вправо. \n\nРазделим задачу на две задачи по вершине острова и решим сначала для левой а потом по аналогии для правой.\n\nБудем идти и запоминать максимальную высоту столбика который нам встретился, если следующий столбик меньше то добавляем разность высот между этими столбиками которая зальется водой, если же произошло обновление максимума, то количество воды не добавляем.\n\n```java\npublic static int isleFlood(int[] h) {\n    int maxPos = 0;\n    for (int i = 0; i < h.length; i++) {\n        if (h[i] > h[maxPos]) {\n            maxPos = i;\n        }\n    }\n\n    int ans = 0;\n    int nowMax = 0;\n    for (int i = 0; i < maxPos; i++) {\n        if (h[i] > nowMax) {\n            nowMax = h[i];\n        }\n        ans += nowMax - h[i];\n    }\n\n    nowMax = 0;\n    for (int i = h.length - 1; i > maxPos; i--) {\n        if (h[i] > nowMax) {\n            nowMax = h[i];\n        }\n        ans += nowMax - h[i];\n    }\n    return ans;\n}\n```\n\n## Задача с собеседования\n\n### Задача 8 - RLE\n\nДана строка (возможно пустая), состоящая из букв A-Z: AAAABBBCCХYZDDDВEEEFFFAAAAAABBBBBBBBBBBBBBBBBB}\nНужно написать функцию RLE, которая на выходе даст строку вида: A4B3C2XYZD4E3F3F3A6B18. И сгенерирует ошибку если на вход пришла невалидная строка.\n\nЕсли символ встречался один раз, он остается без изменений; Если символ повторяется более 1 раза, к нему добавляется количество повторений.\n\n\nПопробуем упростить задачу и написать сначала функцию которая выдаст в ответе строку ABCXYZDEFAB.  \nКладем изначально в переменную значение первого символа, далее проходим по всей строки и проверяем если символ не соответсвует предыдущему то добавляем предыдущий символ и обновляем его. В конце добавляем оставшийся последний символ.\n\n```java\npublic static String easyPeasy(String s){\n    StringBuilder ans = new StringBuilder();\n    char lastCh = s.charAt(0);\n    for (int i = 1; i < s.length(); i++) {\n        if(s.charAt(i) != lastCh){\n            ans.append(lastCh);\n            lastCh = s.charAt(i);\n        }\n    }\n    ans.append(lastCh);\n\n    return ans.toString();\n}\n```\n\nДля полноценного выполнения задачи чтобы посчитать сколько раз символ подряд встретился в строке нужно добавить разность между последней позицией текщего повторяющегося символа и позицией последнего отличающегося символа. Добавим анонимную функцию для вычисления.\n\n```java\npublic static String rle(String s) {\n    StringBuilder ans = new StringBuilder();\n    int lastPos = 0;\n    char lastCh = s.charAt(0);\n\n    BiFunction<StringBuilder, Integer, StringBuilder> pack =\n            (str, cnt) -> {\n                if (cnt > 1) {\n                    return str.append(cnt);\n                }\n                return str;\n            };\n\n    for (int i = 1; i < s.length(); i++) {\n        if (s.charAt(i) != lastCh) {\n            ans.append(lastCh);\n            pack.apply(ans, i - lastPos);\n            lastCh = s.charAt(i);\n            lastPos = i;\n        }\n    }\n\n    ans.append(lastCh);\n    pack.apply(ans, s.length() - lastPos);\n\n    return ans.toString();\n}\n```\n## Вопросы\n\n1. _**Алгоритмы линейного поиска это про алгоритмы Рабина Карпа?**_\nАлгоритм Рабина Карпа - это алгоритм поиска подстроки в строке и его с большой натяжкой можно назвать алгоритмом линейного поиска. Это довольно умный алгоритм.\n\n2. **_Волнует ли вопрос оптимизации в алгоритме линейного поиска?_**\nДа, волнует, но бывают такие последовательности которые не обладают никаким свойством и задачи поиска максимума или поиска значения в последовательности про которую ничего не известно, никак быстрее не сделать мы так или иначе должны посмотреть каждое значение. ","date":"2022-07-24T00:00:00.000Z","path":"/linejnyj-poisk/","icon":"fas fa-code","image":"null","order":3,"category":null,"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[{"value":"Классические задачи линейного поиска","anchor":"#классические-задачи-линейного-поиска"},{"value":"Два прохода","anchor":"#два-прохода"},{"value":"Задача с собеседования","anchor":"#задача-с-собеседования"},{"value":"Вопросы","anchor":"#вопросы"}]}},{"node":{"id":"c5acffab6a1865f81692199e8114cdf1","title":"Множества","content":"\n## Как устроено множество\n\nМножество - это математическая структура, где каждый элемент либо есть, либо его нету.\n\nЧто должно уметь делать множество:\n\n- добавлять элемент\n- проверять наличие элемента\n- удалять элемент\n\n### Как реализовать множество\n\n- Придумаем какую-нибудь функцию которая сопоставляет каждому элементу какое-либо небольшое число\n- Вычислим функцию от элемента\n- Положим элемент в список с номером, равным значению фуекции\n\nСпособ 1: Завести массив где в ячейку с индексом равным числу которое мы кладем класть boolean переменную true что такое число есть. При удалении менять на false. Но тогда если множество будет большим это будет есть большое количество памяти а если таких множеств несколько то съест еще больше.\n\nСпособ 2: Чтобы поместить большое количество элементов в сравнительно небольшой массив нужно сопоставить каждому элементу какое-либо небольшое число. Для этого сформируем соответсвующую функцию. \n\n### Пример функции добавления для чисел\n\n- Функция - последняя цифра числа $X (F(X) = X \\% 10)$. \nФункция которая переводит большие числа в маленькие  - хеш функция.\n- Вычислим функцию от элемента.\n- Положим элемент в список с номером, равным значению функции.\n\nНапример, наша функция преобразует число 137 -> 7 и  17 -> 7. Такая ситуация называется **коллизией**.\nЕсли мы будем класть в ячейку true/false то когда мы получим число 137 мы положим в ячейку с номером 7 флаг true и когда нас запросят узнать есть ли в множестве число 17 мы скажем что да а это неверно.\n\nОдним из решений этой проблемы - класть в ячейку не флаг а само число. Но в таком виде множество не может одновременно хранить в себе значения и 137 и 17 и т.д. \n\nРешением стало - завести список для всех чисел которые имеют одинаковый хеш. \n\nЕсли у нас множество длины N и внем лежит K элементов, то мы можем перебрать все элементов за N + K. Мы будем идти по всем спискам пока список пустой мы его пропускаем, а как только обнаруживаем непустой список у нас запускается внутренний цикл проходит по всем элементам и их возвращает.\n\nЕсли мы решим напечатать значения Set'a, то оно выводся в произвольном порядке (в порядке возрастания значения хеш функции).\n\nДля того чтобы удалить элемент мы сначала находим значение хеш функции находим ячейку с этим знаением и в найденном списке находим нужный элемент. \nУдаление-1: мы перемещаем элементы  на 1 позицию влево, начиная с позиции того элемента который хотим удалить и последний элемент удаляем. \nУдаление-2: копируем последний элемент на место элемента который удаляем и удаляем самый последний это возможно когда не важен порядок элементов.\nУдаление элемента происходит $O(1)$ а его поиск за $O(K/N)$.\n\n```java\npublic class MySet {\n\n    int setSize = 10;\n    int[][] mySet = new int[setSize][];\n\n\n    public void add(int x) {\n        int[] xSet = mySet[x % 10];\n        if (xSet == null) {\n            mySet[x % 10] = new int[]{x};\n        } else {\n            mySet[x % 10] = ArrayUtils.add(xSet, x);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"MySet{\" +\n                \"setSize=\" + setSize +\n                \", mySet=\" + Arrays.toString(mySet) +\n                '}';\n    }\n\n    public boolean find(int x) {\n        for (int now : mySet[x % 10]) {\n            if (now == x) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void delete(int x) {\n        int[] xList = mySet[x % 10];\n        for (int i = 0; i < xList.length; i++) {\n            int now = xList[i];\n            if (now == x) {\n                xList[i] = xList[xList.length - 1];\n                mySet[x % 10] = ArrayUtils.remove(xList, xList.length - 1);\n                return;\n            }\n        }\n    }\n}\n```\n\nМультимножество - такое множество в которое элемент входит несколько раз.\nЧтобы такого не допускать в методе добавления элемента стоит добавить проверку что такого элемента еще нет.\n\n$F(X) = X \\% setSize$ - хеш функция\n\n$MySet$ - хеш таблица\n\nСовпадение значений хеш-функции для разных параметров - коллизия.\n\n### Что можно эффективно хранить в множестве\n\n- Эффективно можно хранить только неизменяемые объекты.\n- Для неизменяемых объектов можно посчитать значение хеш-функции при их создании\n- Хеш функция должна давать равномерное распределение\n\n## Амортизированная сложность\n\nСлишком большой размер - ест много памяти $O(N)$\n\nСлишком маленький размер - большой коэфициент заполнения и медленный поиск и удаление $O(K/N)$\n\nХочется иметь разумный баланс, например, коэфициент заполнения не больше единицы (т.е. $K<=N$)\nТогда все операции в среднем будут занимать $O(1)$\n\nРешение проблемы: Когда таблица наполнится - увеличим ее размер вдвое и перестроим. Нужно пересчитать хеш каждого элемента в зависимости от нового размера и переместить элементы в соответсвующую ячейку.\n\nАмортизированная сложность - это среднее время выполнения опреации (условно).\n\nУ нас амортизированная сложность операции $O(1)$ - всего было N операций и суммарно на это ушло $O(N)$.\n\nВ худшем случае отдельная операция выполняется за $O(N)$ - может не подходить для систем реального времени.\n\n## Примеры задач\n\n### Задача 1. \nПереберем число А за $O(N)$. Переберем число B за $O(N)$. Если их сумма равна X, то вернем эту пару.\n\nРешение 1 (неправильное)\n\nНеправильное, так как не учитывает, что числа должны быть разные.\n\n```java\npublic static int[] findTwoDigitBySum(int[] nums, int sum) {\n    for (int a : nums) {\n        for (int b : nums) {\n            if (a + b == sum) {\n                return new int[]{a, b};\n            }\n        }\n    }\n    return new int[]{0, 0};\n}\n```\n\nРешение (исправленное)\n\n```java\npublic static int[] findTwoDigitBySum(int[] nums, int sum) {\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == sum) {\n                return new int[]{nums[i], nums[j]};\n            }\n        }\n    }\n    return new int[]{0, 0};\n}\n```\n\n### Задача 2\nДан словарь из N слов, длина каждого не превосходит K. \nВ записи каждого из M слов текста (каждое длиной до K) может быть пропущена одна буква. Для каждого слова сказать, входит ли оно (возможно, с одной пропущеной буквой) в словарь.\n\n","date":"2022-07-24T00:00:00.000Z","path":"/mnozhestva/","icon":"fas fa-code","image":"null","order":4,"category":null,"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[{"value":"Как устроено множество","anchor":"#как-устроено-множество"},{"value":"Амортизированная сложность","anchor":"#амортизированная-сложность"},{"value":"Примеры задач","anchor":"#примеры-задач"}]}},{"node":{"id":"6f14f695df4e6204a9c00933b3230a4c","title":"Словари и сортировка подсчётом","content":"\n## Сортировка подсчетом\n\nПусть необходимо отсортировать массив из N целых чисел каждое от 0 до K. \n\nОбычная сортировка займет $O(N logN)$.\n\nБудем считать количество вхождений каждого числа а затем выводить каждое число столько раз сколько оно встречалось. Это займет $O(N+K)$ и $O(K)$ дополнительной памяти.\n\nИнтервал значений можно сдвинуть, чтобы он был не от 0 до K, а от минимального до максимального значения в массиве.\n\nРешение\n\nСоздаем массив и заполняем его нулями. Каждому числу соответсвует ячейка соответствующего индекса в массиве. \nКогда встречаем число увеличиваем счетчик в соответсвуюзей ячейке на единицу. \n\nЗатем идем по всем допустимым значениям и выводим число столько раз сколько оно встречалось.\n\n```java\npublic static void countSort(int[] arr) {\n    int max = Arrays.stream(arr).max().getAsInt();\n    int min = Arrays.stream(arr).min().getAsInt();\n\n    int k = max - min + 1;\n    int[] array = new int[k];\n    Arrays.fill(array, 0);\n\n    for (int i = 0; i < arr.length; i++) {\n        array[arr[i]] +=1;\n    }\n\n    int nowPos = 0;\n    for (int i = 0; i < array.length; i++) {\n        for (int j = 0; j < array[i]; j++) {\n            arr[nowPos] = i;\n            nowPos+=1;\n        }\n    }\n}\n```\n\n### Задача 1\n\nДано два числа X и Y без ведущих нулей. Необходимо проверить, можно ли получить первое из второго перестановкой цифр.\n\nПосчитаем количество вхождений каждой цифры в каждое из чисел и сравним. Цифры будем постепенно добывать из числа справа с помощью %10 и /10.\n\nРазложим цифры в массивы по аналогии с сортировкой подсчетом и сравним их. \n\nСортировка подсчетом уместна когда разница между максимальным и минимальным небольшая.\n\n\n## Словари\n\nСловарь - он как множество но к каждому ключу приписано значение\n\nИскать по значению в словаре нельзя\n\nКонстанта в сложности словарей заметно больше чем у массивов поэтому где можно - лучше использовать сортировку подсчетом.\n\nСортировку подсчетом использовать неразумно если данные разреженные.\n\n### Задача 1\n\nНа шахматной доске N x N находится M ладей (ладья бьет клетки на той же горизонтали и вертикали до ближайшей занятой) \nОпределите сколько пар ладей бьют друг друга. Ладьи задаются парой чисел I и J, обозначающих координаты клетки.\n\n$1<= N <= 10^9, 0<=M<=2*10^5$.\n\nРешение\n\nДля каждой занятой горизонтали и вертикали будем хранить количество ладей на них. Количество пар в горизонтали (вертикали) равно количество ладей минус 1. Суммируем это количество пар для всех горизонталей и вертикалей.\n\n\n## Задел под оптимизацию\n\n","date":"2022-07-25T00:00:00.000Z","path":"/slovari-i-sortirovka-podschyotom/","icon":"fas fa-code","image":"null","order":5,"category":null,"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[{"value":"Сортировка подсчетом","anchor":"#сортировка-подсчетом"},{"value":"Словари","anchor":"#словари"},{"value":"Задел под оптимизацию","anchor":"#задел-под-оптимизацию"}]}},{"node":{"id":"22c652dcdaead037696450e6145fb608","title":"Префиксные суммы и два указателя","content":"","date":"2022-07-24T00:00:00.000Z","path":"/prefiksnye-summy-i-dva-ukazatelya/","icon":"fas fa-code","image":"null","order":6,"category":null,"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[]}},{"node":{"id":"c6c09582f5874298494603fa9eb85f00","title":"Бинарный поиск","content":"","date":"2022-07-24T00:00:00.000Z","path":"/binarnyj-poisk/","icon":"fas fa-code","image":"null","order":7,"category":null,"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[]}},{"node":{"id":"f0bc8f5215664a8dc315c8444ce617be","title":"Сортировка событий","content":"","date":"2022-07-24T00:00:00.000Z","path":"/sortirovka-sobytij/","icon":"fas fa-code","image":"null","order":8,"category":null,"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[]}},{"node":{"id":"e6e65d2d9d8ae4c94f59d2f36ce4023e","title":"Деревья","content":"","date":"2022-07-24T00:00:00.000Z","path":"/derevya/","icon":"fas fa-code","image":"null","order":9,"category":null,"tags":[{"title":"algorithms","path":"/tag/algorithms/"},{"title":"java","path":"/tag/java/"},{"title":"алгоритмы","path":"/tag/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B/"}],"headings":[]}}]}},"relatedTag":null},"context":{}}