[{"title":"Тестирование, Quality control, Quality assurance","path":"/testirovanie-quality-control-quality-assurance/","content":"\nПроцесс Тестирование является частью Quality Control, а Quality Control частью Quality Assurance.\n\n## Обеспечение качества (Quality Assurance)\n\nАктивности, направленные на обеспечение уверенности в том, что требования к качеству будут выполнены. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%9E%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B0)]\n\n**QA (Quality Assurance, обеспечение качества)** – это, собственно, весь комплекс процессов, обеспечивающих качество, наиболее обширное понятие. QA интегрировано во все этапы разработки: от описания проекта до тестирования, релиза и даже пост-релизного обслуживания.\n\nЭто уже проактивная работа, т.к. **_основная задача  обеспечения качества_** – это выстроить систему, которая будет превентивно работать на качество продукта, чтобы при тестировании количество дефектов было минимальным. \n\nВ зависимости от специфики проекта сюда может включаться тестирование документации, подготовка и установка стандартов, анализ качества, выбор инструментов, ревью кода на соответствие стандартам, внедрение каких-то методик по работе с качеством, коммуникационные активности и проч. \n\nЗанимаются Lead специалисты либо менеджеры.\n\n## Контроль качества (Quality Control)\n\nНабор действий, предназначенных для оценивания качества компонента или системы. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C%20%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%B0)]\n\n**QC (Quality Control, контроль качества)** – это часть комплекса QA, которая отвечает за анализ результатов тестирования, поиск ошибок и их устранение. В него входят различные процессы, такие как анализ кода, технические обзоры, анализ дизайна, тестирование и прочее.\n\nQuality Control обеспечивает не только проверку продукта на соответствие требованиям, но и соответствие заранее согласованному уровню качества продукта и готовность к выпуску продукта в продакшен. \nЭто совокупность действий, проводимых над продуктом в процессе разработки, для получения информации о его актуальном состоянии в разрезах:\n- готовность продукта к выпуску,\n- соответствие зафиксированным требованиям,\n- соответствие заявленному уровню качества продукта. \n\n**_Основная задача контроля качества_** – предоставить объективную картину того, что происходит с качеством продукта на разных этапах разработки. \n\nЗанимаются middle специалисты.\n\n## Тестирование программного обеспечения\n\nПроцесс, содержащий все активности жизненного цикла, как динамические, так и статические, касающиеся планирования, подготовки и оценки компонента или системы и связанных с этим результатов работ с целью определить, что они соответствуют описанным требованиям, показать, что они пригодны для заявленных целей и для определения дефектов. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)]\n\n**Testing (Тестирование)** – это уже непосредственно процесс проверки результатов работы на соответствие установленным требованиям. А тестировщик — это специалист, который занимается такой проверкой. Он тестирует компоненты продукта или весь продукт целиком на предмет ошибок или неточностей разработки. Тестирование — один из ключевых процессов в системе обеспечения качества.\n\nПо факту это реактивная работа (выдали – проверил – описал дефекты – исправили), которая может помочь исправить дефекты в уже созданном программном обеспечении, но не более того. Это не значит, что тестирование – это просто (наоборот, профессиональные тестировщики – какие-то сверхлюди, по-моему), но это самая база и минимум, без которого выпускать продукт в принципе нельзя.\n\n**_Основная задача тестирования_** – выявить и зафиксировать дефекты.  \nМогут заниматься junior специалисты.\n\n\n## Пример\n\n**Требование**: В поставляемых тестовых документах должны отсутсвовать персональные данные сотрудников (фамилия и имя)\n\n**_Тестирование_**: Перед окончательным этапом поставки проверяем документацию на отсутсвие персональных данных по заранее составленному списку\n\nНо что делать, если вдруг сотрудник поменял Фамилию или пришел новый сотрудник? \n\n**_Контроль качества_**: Меняем процессы таким образом чтобы в случае если сотрудник поменял Фамилию или пришел новый сотрудник, эти данные добавлялись в текущий список\n\n**_Обеспечение качества_**: Для того чтобы предотвратить попадание ФИО наших сотрудников в тестовые данные мы переходим на процедурную генерацию ФИО. Тестировщикам больше не надо придумывать ФИО для заполнения полей, за них это сделает процедура. Более того, тестировщикам запрещено использовать данные полученные не из процедуры.\n\nВсе эти меры обеспечивают нам уверенность в том, что требование «В поставляемых тестах отсутствуют персональные данные» будет выполнено. Но важно понимать, что это никак не отменяет тестирования выходных данных на наличие ПД.\n\n## Цели тестирования\n- Повысить вероятность того, что приложение, предназначенное для тестирования, будет работать правильно при любых обстоятельствах.\n- Повысить вероятность того, что приложение, предназначенное для тестирования, будет соответствовать всем описанным требованиям.\n- Предоставление актуальной информации о состоянии продукта на данный момент.\n\n#### Источники информации\n\n1. ❗ [Artsiom Rusau QA Life: Тестировщик с нуля / Урок 3. QA, QC, тестирование. Верификация и валидация](https://youtu.be/f3Yjzjsh0aM)\n2. ❗ [Профессия тестировщик: разбираемся в QA, QC и testing](https://tproger.ru/blogs/qa-qc-tester-career/)\n3. ❗ [Что такое качество. Разбираемся в иерархии терминов «QA», «QC» и «тестирование»](https://habr.com/ru/company/rostelecom/blog/647963/)","category":"manual","description":"Разберем разницу между понятиями Тестирование, Quality Control и Quality Assurance в теории и на одном из примеров."},{"title":"Понятие качества, международные стандарты качества","path":"/ponyatie-kachestva-mezhdunarodnye-standarty-kachestva/","content":"\n## Качество программного обеспечения (Software Quality) по ISTQB\n\nСтепень того, насколько компонент или система соответствует сформулированным и подразумеваемым потребностям различных заинтересованных лиц. [[Глоссарий ISTQB](https://glossary.istqb.org/ru/search/%D0%BA%D0%B0%D1%87%D0%B5%D1%81%D1%82%D0%B2%D0%BE)]\n\n## Типы стандартов\n\n**Международные стандарты:**\n- ISO(International Organization for Standardization)/IEC(International Electrotechnical Commission)\n- IEEE(Institute of Electrical and Electronic Engineers.)\n- CMM(Capability Maturity Model - Модель Зрелости Процессов)/CMMI(Capability Maturity Model Integration - Интегрированная Модель Зрелости Процессов)\n\n**Национальные**\n- ГОСТ (применяется на уровне СНГ)\n- ГОСТ Р(РФ), СТБ(Беларуссия), ДСТУ(Украина)\n- BS (British Standard - применяются в Европе)\n\n**Отраслевые** (межнациональные)\n- DO-178B\n\n**Псевдостандарты - \"Стандарты де-факто\"** - стандарты которые были разработаны некоторыми организациями, а потом широко распространились среди какой то отрасли и(или) среди какой-то группы специалистов.\n- PMBOK - Project Menegement Body Of Knoledge, SWEBOK - SoftWare Enginering Body Of Knoledge\nНе имеют юридической силы. Могут иногда использоваться для сертификации, но эта сертификация не очень формальная и держится на уважении к какой-то организации.\n\n**Локальные стандарты внутри организации**\n- регламенты, правила, методики\n\nИмеют для отдельно взятой организации такую же силу как и внешние стандарты. Чаще всего разрабатываются на основе какого-то общепринятого стандарта, модифицированного под нужды конкретной организации.\n\n**Модели**\n- MSF, RUP, XP\n\n**Стандарты для людей**\n- ISTQB - International Software Testing Qualifications Board - подтверждает, что человек(специалист) обладает нужными характеристиками.\n\n## Определение качества ПО по международным стандартам\n\n### ISO/IEC 25010:2011 (ГОСТ Р ИСО/МЭК 25010-2015) Systems and software Quality Requirements and Evaluation (SQuaRE) - Продуктовый стандарт\n#### Требования и оценка качества систем и программного обеспечения (SQuaRE). Модели качества систем и программных продуктов\n\nСерия международных стандартов **_ISO/IEC 25000_**, также известных как _SQuaRE (System and Software Quality Requirements and Evaluation)_, определяет характеристики, по которым оценивается качество программного продукта.\n\nОбновленный стандарт **_ISO/IEC 25010_** содержит терминологию для определения, измерения и оценки качества систем и программных продуктов.  \nОн представляет восемь характеристик качества программного обеспечения, среди которых:   \n- функциональная пригодность\n- уровень производительности\n- совместимость \n- удобство использования\n- надежность\n- безопасность\n- удобство сопровождения\n- портативность\n\nСтандарт _ISO/IEC 25010_ является серьезным пересмотром стандарта _ISO/IEC 9126_. В новый стандарт добавлены дополнительные характеристики и подхарактеристики, которые более подробно описывают процесс качества программного продукта, а также введены уточнения и перегруппировка характеристик для более ясного их понимания.\n\n**Качество программного обеспечения (software quality)**: Степень удовлетворения программным продуктом заявленных и подразумеваемых потребностей при использовании в указанных условиях.\n\n### 1061-1998 IEEE Standard for Software Quality Metrics Methodology\nКачество программного обеспечения - это степень, в которой ПО обладает требуемой комбинацией свойств.\n\n\n### ISO 9000:2000 Quality Management and Quality Assurance\nКачество программного обеспечения - совокупность свойств и характеристик продукции или услуги, которые придают им способность удовлетворять обусловленные или предполагаемые потребности потребителя.\n\n## Характеристики качества ПО по стандарту ISO/IEC 25010\n\n1. **Функциональная Пригодность (Functional Suitability)**\n\nСтепень, в которой продукт или система обеспечивают выполнение функции в соответствии с заявленными и подразумеваемыми потребностями при использовании в указанных условиях.\n\n- **_функциональная полнота (functional completeness)_**: Степень покрытия совокупностью функций всех определенных задач и целей пользователя.\n- **_функциональная корректность (functional correctness)_**: Степень обеспечения продуктом или системой необходимой степени точности корректных результатов.\n- **_функциональная целесообразность (functional appropriateness)_**: Степень функционального упрощения выполнения определенных задач и достижения целей.\n\n_Пример:_ Для решения задачи пользователю предоставляется возможность выполнять только необходимые шаги, исключая любые ненужные.\n\n2. **Уровень Производительности (Performance Efficiency)**\n\nПроизводительность относительно суммы использованных при определенных условиях ресурсов[^Ресурсы могут включать в себя другие программные продукты, конфигурацию программного и аппаратного обеспечения системы и материалы (например, бумагу для печати, носители)].\n\n- **_временные характеристики (time behaviour)_**: Степень соответствия требованиям по времени отклика, времени обработки и показателей пропускной способности продукта или системы.\n- **_использование ресурсов (resource utilization)_**: Степень удовлетворения требований по потреблению объемов и видов ресурсов продуктом или системой при выполнении их функций.\n- **_потенциальные возможности (capacity)_**: Степень соответствия требованиям предельных значений параметров[^В качестве параметров могут быть возможное количество сохраняемых элементов, количество параллельно работающих пользователей, емкость канала, пропускная способность по транзакциям и размер базы данных] продукта или системы.\n\n3. **Совместимость (Compatibility)**\n\nСпособность продукта, системы или компонента обмениваться информацией с другими продуктами, системами или компонентами, и/или выполнять требуемые функции при совместном использовании одних и тех же аппаратных средств или программной среды.\n\n- **_сосуществование (совместимость) (co-existence)_**: Способность продукта совместно функционировать с другими независимыми продуктами в общей среде с разделением общих ресурсов и без отрицательного влияния на любой другой продукт.\n- **_функциональная совместимость (интероперабельность) (interoperability)_**: Способность двух или более систем, продуктов или компонент обмениваться информацией и использовать такую информацию.\n\n4. **Удобство Использования (Usability)**\n\nСтепень, в которой продукт или система могут быть использованы определенными пользователями для достижения конкретных целей с эффективностью, результативностью и удовлетворенностью в заданном контексте использования.\n\n- **_определимость пригодности (appropriateness recognizability)_**: Возможность пользователей понять, подходит ли продукт или система для их потребностей, сравним ли с функциональной целесообразностью (functional appropriateness).\nОпределимость пригодности зависит от возможности распознать уместность продукта или функций системы от первоначальных впечатлений о продукте или системе и/или от какой-либо связанной с ними документации.\n- **_изучаемость (learnability)_**: Возможность использования продукта или системы определенными пользователями для достижения конкретных целей обучения для эксплуатации продукта или системы с эффективностью, результативностью, свободой от риска и в соответствии с требованиями в указанном контексте использования.\n- **_управляемость (operability)_**: Наличие в продукте или системе атрибутов, обеспечивающих простое управление и контроль.\n- **_защищенность от ошибки пользователя (user error protection)_**: Уровень системной защиты пользователей от ошибок.\n- **_эстетика пользовательского интерфейса (user interface aesthetics)_**: Степень \"приятности\" и \"удовлетворенности\" пользователя интерфейсом взаимодействия с пользователем.\n- **_доступность (accessibility)_**: Возможность использования продукта или системы для достижения определенной цели в указанном контексте использования широким кругом людей с самыми разными возможностями[^В диапазон возможностей входят ограничения возможностей, связанные с возрастом].\n\n5. **Надежность (Reliability)**\n\nСтепень выполнения системой, продуктом или компонентом определенных функций при указанных условиях в течение установленного периода времени.\nВ программном обеспечении износа не происходит. Проблемы с надежностью возникают из-за недостатков в требованиях, при разработке и реализации или из-за изменений условий использования.\n\n- **_завершенность (maturity)_**: Степень соответствия системы, продукта или компонента при нормальной работе требованиям надежности.\n- **_готовность (availability)_**: Степень работоспособности и доступности системы, продукта или компонента.\nВ общем, готовность можно оценить как долю общего времени, в течение которого система, продукт или компонент находятся в работающем состоянии. Готовность, таким образом, определяется сочетанием завершенности, которая определяет частоту отказов, отказоустойчивости и восстанавливаемости, которая, в свою очередь, определяет продолжительность времени бездействия после каждого отказа.\n- **_отказоустойчивость (fault tolerance)_**: Способность системы, продукта или компонента работать как предназначено, несмотря на наличие дефектов программного обеспечения или аппаратных средств.\n- **_восстанавливаемость (recoverability)_**: Способность продукта или системы восстановить данные и требуемое состояние системы в случае прерывания или сбоя.\nВ некоторых случаях после сбоя вычислительная система находится в нерабочем состоянии некоторое время, продолжительность которого определяется ее восстанавливаемостью.\n\n6. **Защита, защищенность (Security)**\n\nСтепень защищенности информации и данных, обеспечиваемая продуктом или системой путем ограничения доступа людей, других продуктов или систем к данным в соответствии с типами и уровнями авторизации.\n\nЗащищенность применима также и к данным при передаче в случаях, когда данные сохраняются непосредственно в продукте или системе или вне их.\n\n_Жизнестойкость (survivability)_ (степень, в которой продукт или система продолжают выполнять свою миссию, предоставляя основные услуги своевременно, несмотря на присутствие атак) обеспечивается восстанавливаемостью.\n\n_Защищенность, иммунитет (immunity)_ (степень устойчивости продукта или системы к атакам) обеспечивается целостностью.\n\n_Защищенность (security)_ вносит свой вклад в доверие (trust).\n\n\n- **_конфиденциальность (confidentiality)_**: Обеспечение продуктом или системой ограничения доступа к данным только для тех, кому доступ разрешен.\n- **_целостность (integrity)_**: Степень предотвращения системой, продуктом или компонентом несанкционированного доступа или модификации компьютерных программ или данных.\n- **_неподдельность (non-repudiation)_**: Степень, с которой может быть доказан факт события или действия таким образом, что этот факт не может быть отвергнут когда-либо позже.\n- **_отслеживаемость (accountability)_**: Степень, до которой действия объекта могут быть прослежены однозначно.\n- **_подлинность (authenticity)_**: Степень достоверности тождественности объекта или ресурса требуемому объекту или ресурсу.\n\n7. **Сопровождаемость, модифицируемость (Maintainability)**\n\nРезультативность и эффективность, с которыми продукт или система могут быть модифицированы предполагаемыми специалистами по обслуживанию.\n\nМодификация может включать в себя исправления, улучшения или адаптацию программного обеспечения к изменениям в условиях использования, в требованиях и функциональных спецификациях. Модификации могут быть выполнены как специализированным техническим персоналом, так и рабочим или операционным персоналом и конечными пользователями.\n\nСопровождаемость включает в себя установку разного рода обновлений.\n\nСопровождаемость можно интерпретировать либо как присущее продукту или системе свойство, упрощающее процесс обслуживания, либо как качество при использовании, проверенное на практике специалистами по обслуживанию в целях поддержки продукта или системы.\n\n- **_модульность (modularity)_**: Степень представления системы или компьютерной программы в виде отдельных блоков таким образом, чтобы изменение одного компонента оказывало минимальное воздействие на другие компоненты.\n- **_возможность многократного использования (reusability)_**: Степень, в которой актив может быть использован в нескольких системах или в создании других активов.\n- **_анализируемость (analysability)_**: Степень простоты оценки влияния изменений одной или более частей на продукт или систему или простоты диагностики продукта для выявления недостатков и причин отказов, или простоты идентификации частей, подлежащих изменению.\n Конкретная реализация продукта или системы может включать в себя механизмы анализа собственных дефектов и формирования отчетов об отказах и других событиях.\n- **_модифицируемость (modifiabiIity)_**: Степень простоты эффективного и рационального изменения продукта или системы без добавления дефектов и снижения качества продукта.\n  - Реализация модификации включает в себя кодирование, разработку, документирование и проверку изменений.\n  - Модульность и анализируемость могут оказывать влияние на модифицируемость.\n  - Модифицируемость - это сочетание изменяемости и устойчивости.\n- **_тестируемость (testability)_**: Степень простоты эффективного и рационального определения для системы, продукта или компонента критериев тестирования, а также простоты выполнения тестирования с целью определения соответствия этим критериям.\n\n8. **Переносимость, мобильность (Portability)**\n\nСтепень простоты эффективного и рационального переноса системы, продукта или компонента из одной среды (аппаратных средств, программного обеспечения, операционных условий или условий использования) в другую.\n\nПереносимость можно интерпретировать либо как присущее продукту или системе свойство продукта или системы, упрощающее процесс переноса, либо как качество при использовании, предназначенное для переноса продукта или системы.\n\n- **_адаптируемость (adaptability)_**: Степень простоты эффективной и рациональной адаптации для отличающихся или усовершенствованных аппаратных средств, программного обеспечения, других операционных сред или условий использования.\nВ адаптируемость входит и масштабируемость внутренних потенциальных возможностей (например, экранных полей, таблиц, объемов транзакции, форматов отчетов и т.д.).\nАдаптация может быть выполнена как специализированным техническим персоналом, так и рабочим или операционным персоналом и конечными пользователями.\nЕсли система должна быть адаптирована конечным пользователем, то адаптируемость соответствует пригодности для индивидуализации, как это определено в ИСО 9241-110.\n- **_устанавливаемость (installability)_**: Степень простоты эффективной и рациональной, успешной установки и/или удаления продукта или системы в заданной среде.\nВ случае если продукт или система должны устанавливаться конечным пользователем, устанавливаемость может повлиять на результирующие функциональную целесообразность и управляемость.\n- **_взаимозаменяемость (replaceability)_**: Способность продукта заменить другой конкретный программный продукт для достижения тех же целей в тех же условиях.\nВзаимозаменяемость новой версии программного продукта важна для пользователя при обновлении продукта.\nВо взаимозаменяемость могут быть включены атрибуты как устанавливоемости, так и адаптируемости. Понятие было введено как отдельная подхарактеристика из-за ее важности.\nВзаимозаменяемость снижает риск блокировки таким образом, что, например, при стандартизации форматов файлов допускается применение других программных продуктов вместо используемого.\n\n\n\n#### Источники информации\n\n1. ❗ [ГОСТ Р ИСО/МЭК 25010-2015](https://docs.cntd.ru/document/1200121069)\n\n2. ❗ [Тестирование ПО: Стандарты в области тестирования и их применение на практике](https://youtu.be/kUvPuJuPI-g)\n\n#### Дополнительно можно посмотреть:\n\n❗ [Computer Science Center: Лекция 13. Качество ПО](https://youtu.be/zAxGTb0FFR0)\n","category":"manual","description":"Рассматриваем классификацию международных стандартов качества и характеристики качества по стандарту ISO/IEC 25010"},{"title":"Множества","path":"/mnozhestva/","content":"\n## Как устроено множество\n\nМножество - это математическая структура, где каждый элемент либо есть, либо его нету.\n\nЧто должно уметь делать множество:\n\n- добавлять элемент\n- проверять наличие элемента\n- удалять элемент\n\n### Как реализовать множество\n\n- Придумаем какую-нибудь функцию которая сопоставляет каждому элементу какое-либо небольшое число\n- Вычислим функцию от элемента\n- Положим элемент в список с номером, равным значению фуекции\n\nСпособ 1: Завести массив где в ячейку с индексом равным числу которое мы кладем класть boolean переменную true что такое число есть. При удалении менять на false. Но тогда если множество будет большим это будет есть большое количество памяти а если таких множеств несколько то съест еще больше.\n\nСпособ 2: Чтобы поместить большое количество элементов в сравнительно небольшой массив нужно сопоставить каждому элементу какое-либо небольшое число. Для этого сформируем соответсвующую функцию. \n\n### Пример функции добавления для чисел\n\n- Функция - последняя цифра числа $X (F(X) = X \\% 10)$. \nФункция которая переводит большие числа в маленькие  - хеш функция.\n- Вычислим функцию от элемента.\n- Положим элемент в список с номером, равным значению функции.\n\nНапример, наша функция преобразует число 137 -> 7 и  17 -> 7. Такая ситуация называется **коллизией**.\nЕсли мы будем класть в ячейку true/false то когда мы получим число 137 мы положим в ячейку с номером 7 флаг true и когда нас запросят узнать есть ли в множестве число 17 мы скажем что да а это неверно.\n\nОдним из решений этой проблемы - класть в ячейку не флаг а само число. Но в таком виде множество не может одновременно хранить в себе значения и 137 и 17 и т.д. \n\nРешением стало - завести список для всех чисел которые имеют одинаковый хеш. \n\nЕсли у нас множество длины N и внем лежит K элементов, то мы можем перебрать все элементов за N + K. Мы будем идти по всем спискам пока список пустой мы его пропускаем, а как только обнаруживаем непустой список у нас запускается внутренний цикл проходит по всем элементам и их возвращает.\n\nЕсли мы решим напечатать значения Set'a, то оно выводся в произвольном порядке (в порядке возрастания значения хеш функции).\n\nДля того чтобы удалить элемент мы сначала находим значение хеш функции находим ячейку с этим знаением и в найденном списке находим нужный элемент. \nУдаление-1: мы перемещаем элементы  на 1 позицию влево, начиная с позиции того элемента который хотим удалить и последний элемент удаляем. \nУдаление-2: копируем последний элемент на место элемента который удаляем и удаляем самый последний это возможно когда не важен порядок элементов.\nУдаление элемента происходит $O(1)$ а его поиск за $O(K/N)$.\n\n```java\npublic class MySet {\n\n    int setSize = 10;\n    int[][] mySet = new int[setSize][];\n\n\n    public void add(int x) {\n        int[] xSet = mySet[x % 10];\n        if (xSet == null) {\n            mySet[x % 10] = new int[]{x};\n        } else {\n            mySet[x % 10] = ArrayUtils.add(xSet, x);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"MySet{\" +\n                \"setSize=\" + setSize +\n                \", mySet=\" + Arrays.toString(mySet) +\n                '}';\n    }\n\n    public boolean find(int x) {\n        for (int now : mySet[x % 10]) {\n            if (now == x) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void delete(int x) {\n        int[] xList = mySet[x % 10];\n        for (int i = 0; i < xList.length; i++) {\n            int now = xList[i];\n            if (now == x) {\n                xList[i] = xList[xList.length - 1];\n                mySet[x % 10] = ArrayUtils.remove(xList, xList.length - 1);\n                return;\n            }\n        }\n    }\n}\n```\n\nМультимножество - такое множество в которое элемент входит несколько раз.\nЧтобы такого не допускать в методе добавления элемента стоит добавить проверку что такого элемента еще нет.\n\n$F(X) = X \\% setSize$ - хеш функция\n\n$MySet$ - хеш таблица\n\nСовпадение значений хеш-функции для разных параметров - коллизия.\n\n### Что можно эффективно хранить в множестве\n\n- Эффективно можно хранить только неизменяемые объекты.\n- Для неизменяемых объектов можно посчитать значение хеш-функции при их создании\n- Хеш функция должна давать равномерное распределение\n\n## Амортизированная сложность\n\nСлишком большой размер - ест много памяти $O(N)$\n\nСлишком маленький размер - большой коэфициент заполнения и медленный поиск и удаление $O(K/N)$\n\nХочется иметь разумный баланс, например, коэфициент заполнения не больше единицы (т.е. $K<=N$)\nТогда все операции в среднем будут занимать $O(1)$\n\nРешение проблемы: Когда таблица наполнится - увеличим ее размер вдвое и перестроим. Нужно пересчитать хеш каждого элемента в зависимости от нового размера и переместить элементы в соответсвующую ячейку.\n\nАмортизированная сложность - это среднее время выполнения опреации (условно).\n\nУ нас амортизированная сложность операции $O(1)$ - всего было N операций и суммарно на это ушло $O(N)$.\n\nВ худшем случае отдельная операция выполняется за $O(N)$ - может не подходить для систем реального времени.\n\n## Примеры задач\n\n### Задача 1. \nПереберем число А за $O(N)$. Переберем число B за $O(N)$. Если их сумма равна X, то вернем эту пару.\n\nРешение 1 (неправильное)\n\nНеправильное, так как не учитывает, что числа должны быть разные.\n\n```java\npublic static int[] findTwoDigitBySum(int[] nums, int sum) {\n    for (int a : nums) {\n        for (int b : nums) {\n            if (a + b == sum) {\n                return new int[]{a, b};\n            }\n        }\n    }\n    return new int[]{0, 0};\n}\n```\n\nРешение (исправленное)\n\n```java\npublic static int[] findTwoDigitBySum(int[] nums, int sum) {\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] == sum) {\n                return new int[]{nums[i], nums[j]};\n            }\n        }\n    }\n    return new int[]{0, 0};\n}\n```\n\n### Задача 2\nДан словарь из N слов, длина каждого не превосходит K. \nВ записи каждого из M слов текста (каждое длиной до K) может быть пропущена одна буква. Для каждого слова сказать, входит ли оно (возможно, с одной пропущеной буквой) в словарь.\n\n","description":"Множества"},{"title":"Линейный поиск","path":"/linejnyj-poisk/","content":"\n## Классические задачи линейного поиска\n\nЛинейный поиск - способ поиска, когда перебираются все элементы.\n\nСложность линейного поиска - линейная, т.е. $O(N)$.\n\nОбычно ищут \"подходящий\" элемент или \"наиболее подходящий элемент\".\n\n### Задача 1. Найти первое вхождение положительного числа.\n\nДана последовательность чисел длиной N. Найти первое (левое) вхождение положительного числа X в нее или вывести -1, если число X не встречалось.\n\nРешение:\n\nСначала положим в ответ -1, затем будем перебирать все элементы. Если текущий элемент равен X и ответ равен -1, запишем в ответ текущую позицию.\n\n```java\npublic static int findx(int[] seq, int x) {\n    int ans = -1;\n    for (int i = 0; i < seq.length; i++) {\n        if (ans == -1 && seq[i] == x) {\n            ans = i;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Задача 2. Найти последнее вхождение положительного числа.\n\nДана последовательность чисел длиной N. Найти последнее (правое) вхождение положительного числа X в неё или вывести -1, если число X не встречалось.\n\nРешение:\n\nСначала положим в ответ -1, затем будем перебирать все элементы. Если текущий элемент равен X - запишем в ответ текущую позицию (без проверки что текущая позиция равна -1).\n\n```java\npublic static int findx(int[] seq, int x) {\n    int ans = -1;\n    for (int i = 0; i < seq.length; i++) {\n        if (seq[i] == x) {\n            ans = i;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Задача 3. Найти максимальное число в последовательности.\nДана последовательность чисел длиной N (N>0). Найти максимальное число в последовательности.\n\nРешение:\n\nСначала положим в ответ нулевой элемент последовательности (он точно существует, тк N>0), затем будем перебирать все элементы. Если текущий элемент больше ответа - запишем в ответ текущий элемент.\n\n```java\npublic static int findMax(int[] seq) {\n    int ans = seq[0];\n    for (int i = 1; i < seq.length; i++) {\n        if (seq[i] > ans) {\n            ans = seq[i];\n        }\n    }\n\n    return ans;\n}\n```\n\nЕсли условие допускает пустую последовательность то этот случай нужно обрабатывать отдельно через if.\n\nСтроки сравниваются по символьно и когда символы начинают отличаться можно сказать какая строка меньше или больше. Если строки длинные то сравнение будет идти долго, время равно длине строки. \n\nЛексикографический порядок - это сравнение с учетом регистра.\nАлфавитный порядок - это сравннеие, как в словаре, без учета регистра.\n\nРешение задачи не подойдет для строк, так как будет постоянно перезаписываться значение ans, а для строк это требует больше времени, строки могут быть длинные.\n\nНужно запоминать не значение, а индекс максимального элемента. \n\n```java\npublic static String findMax(String[] seq) {\n    int ans = 0;\n    for (int i = 1; i < seq.length; i++) {\n        if (seq[i].compareTo(seq[ans]) == 0) {\n            ans = i;\n        }\n    }\n\n    return seq[ans];\n}\n```\n\n### Задача 4. Найти максимальное число в последовательности и второе по величине число.\nДана последовательность чисел длиной N (N>1). \nНайти максимальное число в последовательности и второе по величине число (такое, которое будет максимальным, если вычеркнуть из последовательности одно максимальное число).\n\nРешение:\n\nЗаведем две переменные для первого и второго максимума. Возьмем первые два числа из последовательности и запишем большее из них в переменную для первого макисмума, а меньшее - для второго. Пройдем по всей последовательности. Если очередное число больше первого максимума, то запишем во второй макисмум значение первого, а в первый - текущее число. Если только больше второго, запишем текущее число во второй макисмум.\n\n```java\npublic static int[] findMax2(int[] seq) {\n        int max1, max2;\n        if (seq[0] > seq[1]) {\n            max1 = seq[0];\n            max2 = seq[1];\n        } else {\n            max1 = seq[1];\n            max2 = seq[0];\n        }\n        for (int i = 2; i < seq.length; i++) {\n            if (seq[i] > max1) {\n                max2 = max1;\n                max1 = seq[i];\n            } else if (seq[i] > max2) {\n                max2 = seq[i];\n            }\n        }\n        return new int[]{max1, max2};\n    }\n```\n\n### Задача 5. Найти минимальное четное число в последовательности.\nДана последовательность чисел длиной N. Найти минимальное четное число в последовательности или вывести -1, если такого не существует.\n\nРешение:\n\nВ переменную для ответа положим -1. Если очередное число четное, а ответ равен -1 или ответ больше текущего числа, то запишем в ответ текущее число.\n\nУниверсальный способ для решения это завести boolean переменную с признаком встречали ли мы четное число или нет. Изначально она равна fasle, а как встретили четное число делаем ее true.\n\n```java\npublic static int findMinEven(int[] seq) {\n    int ans = 0;\n    boolean isFound = false;\n\n    for (int i = 0; i < seq.length; i++) {\n        int now = seq[i];\n        if (now % 2 == 0 && (!isFound || now < ans)) {\n            ans = now;\n            isFound = true;\n        }\n    }\n    return ans;\n}\n```\n\n## Два прохода\n\n### Задача 6. Вывести все самые короткие слова через пробел.\n\nДана последовательность слов. Вывести все самые короткие слова через пробел.\n\nЕсли решать задачу за один проход, то есть сохранять количество символов в строке и саму строку и при нахождении еще более меньшей обновлять ее, это будет медленно и будет лишняя память заниматься. Так как мы будем накапливать слова, и хороше если добавление слова будет занимать $O(1)$, но может быть и больше, если копировать сами объекты. В Java лучше использовать для этих целей StringBuilder или StringBuffer.\n\n```java\npublic static String shortWords(String[] words) {\n    int minLength = words[0].length();\n    for (String word : words) {\n        if (word.length() < minLength) {\n            minLength = word.length();\n        }\n    }\n\n    StringBuilder ans = new StringBuilder();\n    for (String word : words) {\n        if (word.length() == minLength) {\n            ans.append(word).append(\" \");\n        }\n    }\n\n    return ans.toString();\n}\n```\n\n### Задача 7. Определить, сколько блоков воды осталось после дождя в низинах острова.\n\nИгра PitCraft происходит в двумерном мире, который состоит из блоков размером 1 на 1 метр. Остров игрока представляет собой набор столбцов различной высоты, состоящий из блоков камня и окруженный морем. Над островом прошел сильный дождь, который затопил водой все низины, а не поместившаяся в них вода стекла в море, не увеличив его уровень.\n\nПо ландшафту острова определить, скоолько блоков воды осталось после дождя в низинах острова.\n\n**_Решение:_**\n\nПосле того как вода нальется наш остров примет форму ступенек. Давайте найдем самый высокий столбик(вершину) и до этой вершины будут ступеньки на подъем, вся вода будет сливаться влево от вершины, а все что справа от вершины будет утекать вправо. \n\nРазделим задачу на две задачи по вершине острова и решим сначала для левой а потом по аналогии для правой.\n\nБудем идти и запоминать максимальную высоту столбика который нам встретился, если следующий столбик меньше то добавляем разность высот между этими столбиками которая зальется водой, если же произошло обновление максимума, то количество воды не добавляем.\n\n```java\npublic static int isleFlood(int[] h) {\n    int maxPos = 0;\n    for (int i = 0; i < h.length; i++) {\n        if (h[i] > h[maxPos]) {\n            maxPos = i;\n        }\n    }\n\n    int ans = 0;\n    int nowMax = 0;\n    for (int i = 0; i < maxPos; i++) {\n        if (h[i] > nowMax) {\n            nowMax = h[i];\n        }\n        ans += nowMax - h[i];\n    }\n\n    nowMax = 0;\n    for (int i = h.length - 1; i > maxPos; i--) {\n        if (h[i] > nowMax) {\n            nowMax = h[i];\n        }\n        ans += nowMax - h[i];\n    }\n    return ans;\n}\n```\n\n## Задача с собеседования\n\n### Задача 8 - RLE\n\nДана строка (возможно пустая), состоящая из букв A-Z: AAAABBBCCХYZDDDВEEEFFFAAAAAABBBBBBBBBBBBBBBBBB}\nНужно написать функцию RLE, которая на выходе даст строку вида: A4B3C2XYZD4E3F3F3A6B18. И сгенерирует ошибку если на вход пришла невалидная строка.\n\nЕсли символ встречался один раз, он остается без изменений; Если символ повторяется более 1 раза, к нему добавляется количество повторений.\n\n\nПопробуем упростить задачу и написать сначала функцию которая выдаст в ответе строку ABCXYZDEFAB.  \nКладем изначально в переменную значение первого символа, далее проходим по всей строки и проверяем если символ не соответсвует предыдущему то добавляем предыдущий символ и обновляем его. В конце добавляем оставшийся последний символ.\n\n```java\npublic static String easyPeasy(String s){\n    StringBuilder ans = new StringBuilder();\n    char lastCh = s.charAt(0);\n    for (int i = 1; i < s.length(); i++) {\n        if(s.charAt(i) != lastCh){\n            ans.append(lastCh);\n            lastCh = s.charAt(i);\n        }\n    }\n    ans.append(lastCh);\n\n    return ans.toString();\n}\n```\n\nДля полноценного выполнения задачи чтобы посчитать сколько раз символ подряд встретился в строке нужно добавить разность между последней позицией текщего повторяющегося символа и позицией последнего отличающегося символа. Добавим анонимную функцию для вычисления.\n\n```java\npublic static String rle(String s) {\n    StringBuilder ans = new StringBuilder();\n    int lastPos = 0;\n    char lastCh = s.charAt(0);\n\n    BiFunction<StringBuilder, Integer, StringBuilder> pack =\n            (str, cnt) -> {\n                if (cnt > 1) {\n                    return str.append(cnt);\n                }\n                return str;\n            };\n\n    for (int i = 1; i < s.length(); i++) {\n        if (s.charAt(i) != lastCh) {\n            ans.append(lastCh);\n            pack.apply(ans, i - lastPos);\n            lastCh = s.charAt(i);\n            lastPos = i;\n        }\n    }\n\n    ans.append(lastCh);\n    pack.apply(ans, s.length() - lastPos);\n\n    return ans.toString();\n}\n```\n## Вопросы\n\n1. _**Алгоритмы линейного поиска это про алгоритмы Рабина Карпа?**_\nАлгоритм Рабина Карпа - это алгоритм поиска подстроки в строке и его с большой натяжкой можно назвать алгоритмом линейного поиска. Это довольно умный алгоритм.\n\n2. **_Волнует ли вопрос оптимизации в алгоритме линейного поиска?_**\nДа, волнует, но бывают такие последовательности которые не обладают никаким свойством и задачи поиска максимума или поиска значения в последовательности про которую ничего не известно, никак быстрее не сделать мы так или иначе должны посмотреть каждое значение. ","description":"Линейный поиск"},{"title":"Словари и сортировка подсчётом","path":"/slovari-i-sortirovka-podschyotom/","content":"\n## Сортировка подсчетом\n\nПусть необходимо отсортировать массив из N целых чисел каждое от 0 до K. \n\nОбычная сортировка займет $O(N logN)$.\n\nБудем считать количество вхождений каждого числа а затем выводить каждое число столько раз сколько оно встречалось. Это займет $O(N+K)$ и $O(K)$ дополнительной памяти.\n\nИнтервал значений можно сдвинуть, чтобы он был не от 0 до K, а от минимального до максимального значения в массиве.\n\nРешение\n\nСоздаем массив и заполняем его нулями. Каждому числу соответсвует ячейка соответствующего индекса в массиве. \nКогда встречаем число увеличиваем счетчик в соответсвуюзей ячейке на единицу. \n\nЗатем идем по всем допустимым значениям и выводим число столько раз сколько оно встречалось.\n\n```java\npublic static void countSort(int[] arr) {\n    int max = Arrays.stream(arr).max().getAsInt();\n    int min = Arrays.stream(arr).min().getAsInt();\n\n    int k = max - min + 1;\n    int[] array = new int[k];\n    Arrays.fill(array, 0);\n\n    for (int i = 0; i < arr.length; i++) {\n        array[arr[i]] +=1;\n    }\n\n    int nowPos = 0;\n    for (int i = 0; i < array.length; i++) {\n        for (int j = 0; j < array[i]; j++) {\n            arr[nowPos] = i;\n            nowPos+=1;\n        }\n    }\n}\n```\n\n### Задача 1\n\nДано два числа X и Y без ведущих нулей. Необходимо проверить, можно ли получить первое из второго перестановкой цифр.\n\nПосчитаем количество вхождений каждой цифры в каждое из чисел и сравним. Цифры будем постепенно добывать из числа справа с помощью %10 и /10.\n\nРазложим цифры в массивы по аналогии с сортировкой подсчетом и сравним их. \n\nСортировка подсчетом уместна когда разница между максимальным и минимальным небольшая.\n\n\n## Словари\n\nСловарь - он как множество но к каждому ключу приписано значение\n\nИскать по значению в словаре нельзя\n\nКонстанта в сложности словарей заметно больше чем у массивов поэтому где можно - лучше использовать сортировку подсчетом.\n\nСортировку подсчетом использовать неразумно если данные разреженные.\n\n### Задача 1\n\nНа шахматной доске N x N находится M ладей (ладья бьет клетки на той же горизонтали и вертикали до ближайшей занятой) \nОпределите сколько пар ладей бьют друг друга. Ладьи задаются парой чисел I и J, обозначающих координаты клетки.\n\n$1<= N <= 10^9, 0<=M<=2*10^5$.\n\nРешение\n\nДля каждой занятой горизонтали и вертикали будем хранить количество ладей на них. Количество пар в горизонтали (вертикали) равно количество ладей минус 1. Суммируем это количество пар для всех горизонталей и вертикалей.\n\n\n## Задел под оптимизацию\n\n","description":"Словари и сортировка подсчётом"},{"title":"Сложность, тестирование, особые случаи","path":"/slozhnost-testirovanie-osobye-sluchai/","content":"\n## Сложность\n\nДля тренировки нужно написать 10000 строк кода.\nДля этого можно использовать сайты leetcode.com, codeforces.com\n\n**Сложность алгоритма** - это порядок количества действий, которые выполняет алгоритм.\n\nЕсли сложность $O(N)$ - это значит, что скорость алгоритма зависит напрямую от количества данных и такую сложность называют **линейной**. \nНапример, обычный цикл от $1$ до $N$.\n\nЕсли в программе два вложенных цикла, каждый от $1$ до $N$, тогда сложность составит $O(N^2)$.\n\n$O$ никак не зависит от константы.  \n$100*N = O(N), 2*N=O(N)$. Здесь 2 и 100 - константы, не зависящие от размера входных данных.  Константы не так сильно влияют на скорость алгоритма при больших параметрах.\n\nНапример, алгоритм, который работает за $O(100*N)$ будет работать лучше, чем $O(1*N^2)$, поэтому константа не так принципиальна.\n\nТ.е. если в алгоритме выполняется цикл, то не важно сколько действий выполняется внутри цикла, важно сколько вхождений выполнится.\n\n$O$(O-большое) означает, что наш алгоритм работает не более, чем за столько действий сколько указано в скобках, например $O(N) = 10 * N$ - означает что найдется такое число, в нашем случае 10, что наш алгоритм гарантировано совершит не больше, чем 10 * N  действий. Чем асимптотическая сложность ниже, тем лучше, тем быстрее решается.\n\nСравнение алгоритмов по асимптотической сложности имеет смысл проводить только для больших значений параметров, пока он маленький там может произойти, что угодно :). \n\nЕще существует **\"пространственная сложность\"** - количество использованной памяти, сколькдополнительной памяти потребляет наш алгоритм.\nПамяти алгортим не может потребить больше чем он потратил времяБ потому что чтобы что то положить в ячейку памяти это тоже элементарная операция. \nНо иногда алгоритмы отличаются и по дополнительной памяти которую они употребляют. \n\n### Задача №1. Условие.\nДана строка в кодировке UTF-8.  \nНайти самый часто встречающийся в ней символ. Если несколько символов встречаются одинаково часто, то можно вывести любой.\n\n### Задача №1. Решение 1.\n\nПереберем все позиции и для каждой позиции в строке еще раз переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.\n\n--- \n\nЗаводим внешние переменные для максимального количества повторений и для значения символа. \n\nВнешний цикл сначала выбирает первый символ и далее проходит по строке и ищет сколько раз этот символ в ней встречается, запоминаем значение символа и количество повторений и сохраняем их во внешнюю переменную. \n\nЗатем переходим ко второму символу и также проверяем сколько раз он встретился, если количество его повторений больше, чем во внешней переменной, то обновляем значения для максимального количества повторений и для значения символа во внешних переменных и так далее до конца строки.\n\n**_Сложность алгоритма: _**$O(N^2)$, тк 2 вложенных цикла.\n\n```java\npublic static char maxRepeatableChar(String s) {\n    int ansCount = 0;\n    char ans = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        char nowChar = s.charAt(i);\n        int nowCount = 0;\n\n        for (int j = 0; j < s.length(); j++) {\n            if (s.charAt(j) == nowChar) {\n                nowCount += 1;\n            }\n        }\n\n        if (nowCount > ansCount) {\n            ansCount = nowCount;\n            ans = nowChar;\n        }\n    }\n    return ans;\n}\n```\n\nНо есть более эффективное решение. \n\n### Задача №1. Решение 2.\n\nПереберем все символы, встречающиеся в строке, а затем переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.\n\n---\n\nПолучаем список уникальных букв через Set. \n\nПроходим по нему в цикле и для каждой из букв запускаем цикл, который подсчитывает количество повторений для этой буквы. \n\nЗаписываем в счетчик и возвращаем искомый символ.\n\n**_Сложность алгоритма: _**$O(N*K)$, где K - количество уникальных букв, цикл по ним чтобы узнать, сколько каждая из них встречалась раз, N - общее количество букв, цикл по N, чтобы найти количество повторений для каждой из уникальных букв.\n\n```java\npublic static char maxRepeatableChar(String s) {\n    Set<Character> str = s.chars().mapToObj(e -> (char) e).collect(Collectors.toSet());\n\n    char ans = 0;\n    int ansCount = 0;\n\n    for (Character now : str) {\n        int nowCount = 0;\n        for (int j = 0; j < s.length(); j++) {\n            if (s.charAt(j) == now) {\n                nowCount += 1;\n            }\n        }\n        if (nowCount > ansCount) {\n            ansCount = nowCount;\n            ans = now;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Задача №1. Решение 3.\n\nЗаведем словарь, где ключом является символ, а значением - сколько раз он встретился. \n\nПроходим в цикле по всем символам строки и если символ встретился впервые - создаем элемент словаря с ключом, совпадающим с этим символом и значением ноль. Далее для текущего символа в словаре прибавляем к элементу словаря с ключом, совпадающим с этим символом единицу. \n\nПосле выполнения прохода по всем символам, запускаем цикл прохода по ключам словаря и сравниваем значение по ключу с текущим максимальным повторением, если значение больше то переписываем символ в ответе и макимальное количество повторений.\n\n**_Сложность алгоритма: _**$O(N + K) = O(N)$, N - количество проходов пока формировали словарь, K - количество прохода только по (уникальным) ключам. Но так как K обычно меньше N то можно сказать что алгоритм выполняется за $O(N)$.\n\n```java\npublic static char maxRepeatableChar(String s) {\n    char ans = 0;\n    int ansCount = 0;\n    Map<Character, Integer> dict = new HashMap<>();\n\n    for (int i = 0; i < s.length(); i++) {\n        char now = s.charAt(i);\n        if (!dict.containsKey(now)) {\n            dict.put(now, 0);\n        }\n        dict.put(now, dict.get(now) + 1);\n    }\n\n    for (Character key : dict.keySet()) {\n        if (dict.get(key) > ansCount) {\n            ansCount = dict.get(key);\n            ans = key;\n        }\n    }\n\n    return ans;\n}\n```\n\n### Сравниваем затраченное время и память (дополнительную)\n\n|Решение|Время|Память|\n|---|---|---|\n|#1 Проход по строке для каждого символа|$O(N^2)$|$O(N)$ - так как храним только саму строку|\n|#2 Проход по строке для каждого символа в множестве|$O(N*K)$|$O(N+K) = O(N)$ - храним строку и множество ($K$)|\n|#3 Использование словаря|$O(N)$|$O(K)$ - храним только словарь из K элементов|\n\n## Особые случаи\n\n### Сумма последовательности\n\nВ данном алгоритме не обязательно делать проверку на пустую строку так как и без этой проверки у нас выведется ноль.\n\n```java\npublic static int sequenceSum(String s) {\n    int[] sequence = s.chars().toArray();\n    int sequenceSum = 0;\n    for (int i = 0; i < sequence.length; i++) {\n        sequenceSum += sequence[i];\n    }\n    \n    return sequenceSum;\n}\n```\n\n### Максимум последовательности\n\nВ этом алгоритме мы не можем задать начальное значение нулем, тк в массиве могут быть еще и отрицательные значения, поэтому необходимо добавить ночальную проверку на пустую строку и при выполнении алгоритма стартовому значению присвоить первое значение в массиве.\n\n```java\npublic static double sequenceMax(String s) {\n    int[] sequence = s.chars().toArray();\n    if (sequence.length == 0) {\n        return Double.NEGATIVE_INFINITY;\n    } else {\n        int sequenceMax = sequence[0];\n        for (int i = 0; i < sequence.length; i++) {\n            if (sequence[i] > sequenceMax) {\n                sequenceMax = sequence[i];\n            }\n        }\n        return sequenceMax;\n    }\n}\n```\n\n## Тестирование\n\nПри тестировании алгоритма нужно проверить:\n\n- тесты из условия (если есть)\n- общие случаи\n- особые случаи (все числа отрицательные, пустая последовательность)\n\nТесты для алгоритма на поиск максимума последовательности:\n\n- 1 3 2 - общий случай (максимум в середине)\n- 1 2 3, 3 2 1 - максимум по краям \n- 1 1 1 - все элементы одинаковы\n- 1 - один элемент\n- _ - пустая последовательность\n- -2 -1 -3 - все числа отрицательные\n\n### Советы по составлению тестов\n\n- Если есть примеры - реши их руками и сверь ответ. Если не совпадает, то либо правильных ответов может быть несколько, либо ты неправильно понял задачу;\n- Сначала составь несколько примеров и реши задачу руками, чтобы лучше понять условие и чтобы потом было с чем сравнить;\n- Проверь последовательность из одного элемента и пустую последовательность;\n- \"Краевые эффекты\" - проверь что программа работает корректно в начале и конце последовательности сделай тесты чтоы ответ находился на первом и на последнем месте последовательности;\n- Составь покрытие всех ветвлений, так чтобы был тест, который входит в каждый if и else;\n- Подбери тесты чтобы не было ни одного входа в цикл;\n- Один тест - одна возможная ошибка;\n\n## Вопросы\n\n1. **_Что приоритетней оптимизация по памяти или по времени исполнения?_**\n\nЧаще всего по времени исполнения, а если есть несколько алгориитмов с одинаковым временем то уже по памяти.\nНо бывают редкие задачи, где память играет решающее значение.\n\n2. **_Почему в решение №3 мы использовали Set но не считали его асимптотическую сложность?_**\n\nДобавление в Set происходит за $O(1)$ времени. Объяснение будет в следующих лекциях.\n\n3. **_Как проверить алгоритм, если не знаешь где может быть ошибка?_**\n\n    1. пишем самый простой базовый алгоритм для решения задачи\n    2. пишем генератор маленьких массивов из случайных чисел\n    3. запускаем цикл и сравниваем ответ нашего алгоритма с ответом примитивного алгоритма","description":"Сложность, тестирование, особые случаи"},{"title":"Префиксные суммы и два указателя","path":"/prefiksnye-summy-i-dva-ukazatelya/","content":"","description":"Префиксные суммы и два указателя"},{"title":"Бинарный поиск","path":"/binarnyj-poisk/","content":"","description":"Бинарный поиск"},{"title":"Сортировка событий","path":"/sortirovka-sobytij/","content":"","description":"Сортировка событий"},{"title":"Алгоритмы (курс Яндекс)","path":"/algoritmy-kurs-yandeks/","content":"\n1. [Сложность, тестирование, особые случаи](/slozhnost-testirovanie-osobye-sluchai/)\n2. [Линейный поиск](/linejnyj-poisk/)\n3. [Множества](/mnozhestva/)\n4. [Словари и сортировка подсчётом](/slovari-i-sortirovka-podschyotom/)\n5. [Префиксные суммы и два указателя](/prefiksnye-summy-i-dva-ukazatelya/)\n6. [Бинарный поиск](/binarnyj-poisk/)\n7. [Сортировка событий](/sortirovka-sobytij/)\n8. [Деревья](/derevya/)\n\nhttps://www.youtube.com/playlist?list=PL6Wui14DvQPySdPv5NUqV3i8sDbHkCKC5\n\n\n","category":"java","description":"Алгоритмы (курс Яндекс)"},{"title":"Сортировки. Быстрая, слиянием и поразрядная","path":"/sortirovki-bystraya-sliyaniem-i-porazryadnaya/","content":"\n## Быстрая сортировка. Quick sort","description":"Сортировки. Быстрая, слиянием и поразрядная"},{"title":"Деревья","path":"/derevya/","content":"","description":"Деревья"}]