---
title: Linux
category: testops
description: Linux
tags: ["Автоматизация тестирования"]
icon: "fas fa-robot"
image: "null"
date: 2022-06-12
keywords: "qa, Автоматизация тестирования"
order: 04
links: [
        {
          items: [
                { title: "Микросервисная архитектура", link: "//mikroservisnaya-arhitektura//" },
                { title: "Docker", link: "/docker/" },
                { title: "Kubernetes", link: "/kubernetes/" },
                { title: "Linux", link: "/linux/" },
                { title: "Общие вопросы TestOps", link: "/obshhie-voprosy-test-ops/" },
          ]
        }
      ]
---

## Terminal: основы

- pwd  - вывести текущую директорию (print working directory)

- ls - вывести содержимое директории (list directory content)
    - ls --all --human-readable -l путь
    - ls -a -h -l путь
    - ls -ahl путь ls -lah путь

-a, --all — выдавать все файлы в каталогах, включая скрытые файлы, начинающиеся с точки.

-h, --human-readable — добавлять к каждому размеру файла букву размера, например, M для двоичных мегабайт (`мебибайт').

-l, --format=long, --format=verbose — в дополнении к имени каждого файла, выводятся тип файла, права доступа к файлу, количество ссылок на файл, имя владельца, имя группы, размер файла в байтах и временной штамп (время последней модификации файла, если не задано другое). Для файлов с временем больше чем 6 месяцев назад или больше, чем 1 час в будущее, временной штамп содержит год вместо времени дня.

- man команда - справка о команде (для выхода: Q)
- clear - очистить экран терминала
- exit - закрыть терминал

### Специальные символы:
- . текущая директория
- .. директория на уровень выше
- ~ домашняя директория
- \* любое количество любых символов
- ? ровно один любой символ


- mkdir путь_до_директории - создать директорию
- mkdir -p путь_до_директории - создать директорию и ее “родителей”
- touch путь_до_файла - создать файл
- cd путь_до_директории - войти в директорию
- rm путь_до_файла - удалить файл
- rm -r путь_до_директории -  удалить директорию
- rm -rf путь_до_директории - удалить директорию (без вопросов)
- сp путь_до_файла1 путь_до_файла2 - скопировать файл1 в файл2
- cp -r путь_до_дир1 путь_до_дир2 - скопировать дир1 в дир2
- mv путь1 путь2 - переместить директорию или файл

## Запуск исполняемых файлов
- Ctrl + C - прервать выполнение
- Ctrl + Z - приостановить выполнение
    - fg продолжить (foreground)
    - bg продолжить в фоновом режиме (background)
- program & - запустить выполнение программы сразу в фоновом режиме

- ./имя_программы - запустить выполнение программы из текущей директории
- /полный/путь/имя_программы

- chmod +x имя_программы - сделать программу исполняемой

## Ввод/вывод
- cat файл - вывести содержимое файла на экран
- less файл - открыть файл на чтение
    - q – выход; 
    - / – поиск;
    - g – в начало; 
    - G – в конец
- nano файл - редактировать файл
    - Ctrl + X – выход

- Программа < файл - брать stdin из файла

- Программа > файл - выводить stdout в файл
- Программа >> файл - аналогично, но с дозаписью в файл

- Программа 2> файл - выводить stderr в файл
- Программа 2>> файл - аналогично, но с дозаписью в файл

- Прогр1 | Прогр2 | … | ПрогрN - передать stdout Прогр1 в качестве stdin для Прогр2, далее stdout Прогр2 в качестве stdin для Прогр3 и т.д.

## Скачивание файлов из интернета
- wget ссылка - скачать файл по ссылке и сохранить в текущей директории
- wget -P путь_до_директории ссылка - скачать файл по ссылке и сохранить в директории заданной путем
- wget -O путь_до_файла ссылка - скачать файл по ссылке и сохранить под указанным именем

- wget -c ссылка - докачать файл по ссылке в случае обрыва связи
- wget --spider ссылка - проверить доступность файла по ссылке
- wget -i текстовый_файл - скачать несколько файлов по ссылкам из текстового файла

- wget -r -l глубина ссылка - рекурсивное скачивание файлов по ссылке на указанную глубину(по умолчанию глубина 5)
- wget -r -A тип,тип,...,тип ссылка - рекурсивное скачивание файлов только определенного типа (типов)

## Работа с архивами

### Распаковка архивов
- unzip архив.zip - распаковать содержимое архива.zip
- gunzip архив.gz - распаковать содержимое архива.gz, файл архив.gz удалить

### Создание архивов
- zip архив.zip файл1 файл2 ... - запаковать перечисленные файлы и/или папки в архив.zip
- gzip файл - запаковать файл в файл.gz, исходный файл удалить
- tar -cvf архив.tar файл1 файл2 ... - запаковать перечисленные файлы и/или папки в архив.tar (без сжатия)
- gzip архив.tar - запаковать архив.tar в архив.tar.gz, исходный архив.tar удалить
- tar -zcvf архив.tar.gz файл1 файл2 ... - запаковать перечисленные файлы и/или папки в архив.tar.gz (c сжатием при помощи gzip)

### Распаковка архивов
- tar -xvf архив.tar - распаковать архив.tar
- tar -xzvf архив.tar.gz - распаковать архив.tar.gz (с использованием gunzip)

Еще один архиватор:
- bzip2 файл
- bunzip2 файл.bz2
- tar -cjvf архив.tar.bz2 файл1 файл2 ...
- tar -xjvf архив.tar.bz2

### Сжатие/распаковка без удаления
- gzip -c файл > файл.gz
- gunzip -c файл.gz > файл
- bzip2 -c файл > файл.bz2
- bunzip2 -c файл.bz2 > файл

## Работа на сервере

Для входа на сервер, нужно знать:
1) адрес сервера,
2) логин и пароль.

### Команда входа
ssh логин@адрес_сервера -p порт

на клиенте хранится закрытый ключ ~/.ssh/id_rsa, ~/.ssh/id_rsa.pub  
на сервере открытый ключ ~/.ssh/authorized_keys

### Создание ключа
- ssh-keygen - создание ключа
- ssh-add - сообщить системе о ключе
- cat ~/.ssh/id_rsa.pub - просмотр публичного ключа:
- nano ~/.ssh/authorised_keys - редактирование авторизованных ключей (на сервере)

### Копирование файлов
- scp -P порт логин@адрес_сервера:путь1 путь2 - с сервера (путь1) на клиента (путь2)
- scp -P порт путь1 логин@адрес_сервера:путь2 - с клиента (путь1) на сервер (путь2)

### Установка, удаление и обновление программ

- sudo apt-get install программа - Установка программ через терминал
- sudo apt-get remove программа - Удаление программ через терминал:
- sudo apt-get update - Обновление ссылок на пакеты:
- sudo apt-get upgrade - Обновление установленных пакетов:
- sudo apt-get install --only-upgrade программа - Обновление отдельной программы:

### контроль запускаемых программ
- jobs - посмотреть запущенные программы
- fg %<номер> - продолжить программу с этим номером
- bg %<номер> - продолжить программу с этим номером в фоновом режиме 
- ps - посмотреть ваши процессы
- top - отслеживать процессы в реальном времени
- top -u <имя пользователя> - отслеживать процессы этого пользователя 
- kill <номер процесса> - завершить процесс с этим номером
- kill -9 <номер процесса> - “убить” процесс с этим номером

### Многопточные приложения
- free -g - информация об оперативной памяти
- nproc - количество ядер процессора
- lscpu - детальная информация о процессоре
- bowtie2-build - запуск построения индекса генома
    - bowtie2-build <геном> <индекс>
        - bowtie2-build ref.fasta index
- bowtie2 - запуск выравнивателя bowtie
    - bowtie2 -x <индекс> -U <риды>
        - bowtie2 -x index -U reads.fastq
    - bowtie2 -x <индекс> -U <риды> -p <количество потоков>
        - bowtie2 -x index -U reads.fastq -p 4

### Менеджер терминалов
- Ctrl + Shift + T - открыть новую вкладку в терминале
- Alt + <цифра> - перейти в указанную вкладку
- Ctrl + Shift + W - закрыть текущую вкладку
- tmux - запустить tmux
- Ctrl + B - перейти в режим команд
- Ctrl + B и C (зажать Ctrl+B, отпустить, затем нажать С) - создать новую вкладку
- Ctrl + B и <цифра> - перейти в указанную вкладку
- Ctrl + B и N / Ctrl + B и P - перейти в следующую / предыдущую вкладку
- Ctrl + B и X (или exit) - закрыть вкладку
- Ctrl + B и D - временно выйти из tmux
- tmux attach / tmux a - вернуться в tmux
- tmux list-sessions - посмотреть список запущенных tmux’ов
- Ctrl + B и PgUp - перейти в режим просмотра истории
- PgUp, PgDown, стрелки - перемещать курсор по истории
- Esc, Ctrl + C - выйти из режима просмотра истории

## Редактор Vim
### Вход
vim
vim файл
vim файл1 файл2 файл3 ...

### Главные команды
:q - выход
:help - справка
vimtutor - очень хороший автотуториал!

### Режимы работы
1. normal
- Режим по умолчанию
- Любая клавиша воспринимается как команда
- «Сложные» команды начинаются с ‘:’

2. insert
- Режим ввода текста — все, что вы
нажимаете, вставляется (заменяется).
- Выход через `<Esc>`, `<Ctrl+c>`

3. visual
- Режим выделения

### Перемещение
- По символам:
    - Стрелочки
    - h,j,k,l
- По словам:
    - w, W — в начало следующего слова
    - e, E — в конец
    - b, B — в начало предыдущего

- Еще крупнее:
0,^,$ — начало строки, первый непробельный символ, конец строки
- Совсем крупно:
 - gg — начало файла
 - G — конец
 - :21 `<Enter>` — перейти к строке 21
 - `<Ctrl+D>`, `<Ctrl+U>` — вниз/вверх на N строчек, где N обычно пол-экрана

### Удаление
- По символам:
    - x — символ под курсором
    - X — символ до курсора
- Сразу много: d [<кол-во>] <ход>
    - dе — удалить до конца текущего слова
    - d$ — удалить до конца строки
    - d5w — удалить пять слов
- Специальная команда
    - dd — удалить строку (или, например, d10d)

### Создание
i — войти в insertion mode
a — сдвинуть курсор вправо и войти в insertion mode
I = ^i
A = $a
o — вставить пустую строку снизу и редактировать ее
O — то же, но строка сверху

### Копирование
y <кол-во> <ход> — скопировать
yy — скопировать строку

### Вставить
p — вставить после
P — вставить перед

### Поиск и замена
#### Поиск
- /<текст> — искать <текст> вперед
- ?<текст> — назад
- n — следующее вхождение, 
- N — предыдущее

#### Замена
- :%s/<что ищем>/<на что меняем>/<флаги>
- флаги: 
    - g – много замен в строке, 
    - с – подтверждение

### Полезные команды
#### Отмена/возврат
- u — отменить последнее действие
- `<Ctrl+r>` — вернуть отмененное действие

#### Сохранение работы
- :w — сохранить изменения
- :wq — сохранить и выйти
- :q! — выйти без сохранения
- :w `<файл>` — сохранить изменения в `<файл>`

## Программирование на bash
- оболочка (shell) – интерпретатор команд
- sh (Bourne shell) – стандарт и доступна почти в любом дистрибутиве (1977)
- bash (Bourne again shell) – усовершенствованная и модернизированная вариация sh (1989)
- csh, tcsh, zsh, ...

### Создаем программу
vim my_first_script.sh
```
#!/bin/bash
echo "Hello, world!"
```

### Запускаем программу
chmod +x my_first_script.sh  
./my_first_script.sh

### Переменные
Переменная (variable) - именованная область памяти

**имя (name):**
- буквы, цифры, _;
- не может начинаться с цифры.

**значение (value):**
- числа;
- строки (если есть пробелы, то в кавычках);
- отдельные символы.

### Запись (перезапись) значения
<имя>=<значение>
```
path=~/Docs
```

### Чтение
$<имя> или ${<имя>}
```
path2=$path/file1.txt # path2=~/Docs/file1.txt
echo “Path is $path2” # Path is ~/Docs/file1.txt
echo “Path is ${path}2” # Path is ~/Docs2
```

### Аргументы
#### Передача аргументов скрипту:
./script.sh arg1 arg2 arg3 ...

#### Обработка внутри скрипта:
$1 первый аргумент  
$2 второй аргумент  
...

\$0 имя скрипта  
$# количество аргументов

```
var=”Первый аргумент равен $1”
echo ”Всего было передано $# аргументов”
```

### Ветвление: основы

#### Синтаксис:
```
if [[ условие ]]
then
    # действия, если условие истинно
fi
```


#### Условия (строки):
- -z <строка> # строка пуста
- -n <строка> # строка не пуста
- <стр1> == <стр2> # строки равны
- <стр1> != <стр2> # строки не равны

Пример:
```
if [[ -z $1 ]]
then
 echo “Первый аргумент пустой!”
fi
```
```
if [[ $var1 == $var2 ]]
then
 echo “Переменные равны!”
fi
```

#### Условия [числа (строки)]:

<число/строка> операция <число/строка>

- -eq == # равно
- -ne != # не равно
- -lt < # меньше
- -le # меньше или равно
- -gt > # больше
- -ge # больше или равно

операции вида “-хх” – только для чисел!  
операции-знаки – только для строк!  

#### Условия (файлы):
- -e <путь> # путь существует
- -f <путь> # это файл
- -d <путь> # это директория
- -s <путь> # размер файла больше 0
- -x <путь> # файл исполняемый

#### Условия (логические):
- ! # отрицание логического выражения
- && # логическое «И»
- || # логическое «ИЛИ»

### Ветвление: альтернативы
#### Синтаксис:
```
if [[ условие ]]
then
    # действия, если условие истинно
еlse
    # действия, если условие ложно
fi
```

```
if [[ условие1 ]]
then
    # действия, если условие1 истинно
elif [[ условие2 ]]
then
    # действия, если условие1 ложно,
    # но условие2 истинно
еlse
    # действия, если оба условия ложны
fi
```

```
case переменная in
знач1)
    # действия, если переменная==знач1
    ;;
знач2)
    # действия, если переменная==знач2
    ;;
*)
    # действия, если переменная
    # не равна ни одному из вариантов
esac
```

### Циклы
#### Синтаксис:
```
for переменная in список_значений
do
    # действия, каждый раз переменная
    # принимает следующее значение
    # из списка
done
```

```
for переменная in список_значений
do
    # действия, каждый раз переменная
    # принимает следующее значение
    # из списка
done
```

break прервать выполнение  
сontinue перейти на след. значение


```
while [[ условие ]]
do
    # действия, пока условие истинно
done
```

- read переменная - записать введенное пользователем значение в переменную


### Арифметика
#### Синтаксис:
let “переменная = выражение”

Пример:
```
let “c = 1 + 1”
let “c = a + b”
```
 
#### Операции:
- +, -, /, * стандартные
- % остаток от деления
- ** возведение в степень

#### Cокращение:
let “a=a+b” эквивалентно let “a+=b”

### Внешние программы
#### Синтаксис:
переменная=`программа`

Пример:
```
a=`echo “test”`
files=`ls ~`
```

#### Код возврата:
- 0 корректное завершение
- не 0 в процессе работы были ошибки

#### Узнать код:
$?

#### Выйти с кодом:
exit код

Пример:
```
touch file.txt
echo $?
```


Проверка кода возврата:
```
if `программа`
then
    # действия, если код 0
еlse
    # действия, если код не 0
fi
```

### Функции
#### Задаем функцию:
```
имя_функции ()
{
    # действия
} 
```

#### Используем функцию:
...
имя_функции
...

#### Функции с параметрами:
```
имя_функции ()
{
    # действия с $1, $2, … , $#
}
```

#### Используем функцию:
...
имя_функции аргумент1 аргумент2 ...
...

#### Переменные:
```
имя_функции ()
{
    var_global=1
    local var_local=1
}
```

#### Используем:
имя_функции
```
echo $var_global # выведет 1
```
```
echo $var_local # ничего не выведет
```

#### Компактная запись:
```
имя_функции () { действ1; действ2; }
```

#### Актуально и в других конструкциях:
```
if [[ $var==”test ”]]; then
...
for i in 1 2 3 4 5; do
...
```

## Продвинутый поиск и редактирование
- find -iname “<имя файла>” не учитывать регистр
- find -path “<путь>” найти указанный путь
- find -size <размер> выводить файлы указанного размера 
- find -maxdepth <число> искать не больше чем на заданное число уровней вниз
- find -mindepth <число> искать начиная с заданного числа уровней вниз

### Поиск строк по регулярному выражению
- grep -l “<строка>” <файл> список файлов с этой строкой
- grep -L “<строка>” <файл> список файлов, где этой строки нет
- grep -n “<строка>” <файл> выводить номер строки в файле
- grep -m <число> “<строка>” <файл> не искать дальше после заданного числа вхождений
- grep -A <число> “<строка>” <файл> выводить это число строк после вхождения
- grep -B <число> “<строка>” <файл> выводить это число строк до вхождения
- grep -C <число> “<строка>” <файл> выводить это число строк вокруг вхождения
- grep -E “<шаблон>” <файл> найти указанный шаблон в файле
- grep -E “<шаблон>” <файл> найти указанный шаблон в файле
- grep -E “^go” <файл> найти строки, начинающиеся с “go”
- grep -E “go$” <файл> найти строки, оканчивающиеся на “go”
- grep -E “c[au]t” <файл> найти все слова, содержащие cut и cat
- grep -E “ [a-z]ight ” <файл> слова из 5 букв, кончающиеся на “ight”
- grep -E “ [a-z]*ight ” <файл> слова из 4 и более букв, кончающиеся на “ight” 
- grep -E “ [a-z]+ight ” <файл> слова из 5 и более букв, кончающиеся на “ight”
- grep -E “ [a-z]?ight ” <файл> слова из 4-5 букв, кончающиеся на “ight”
- grep -E “ [a-zA-Z]*ight ” <файл> слова, кончающиеся на “ight” (разрешены большие буквы)

- cat <файл> | sed ‘инструкция’
- sed ‘инструкция’ <файл> - потоковый редактор: читает строчки из stdin (или из файла), обрабатывает их по инструкции и пишет в stdout

### Если хотим писать в файл
- \> <файл> обычное перенаправление
- -i, --in-place перезаписать входной файл
- sed ‘s/John/Nick/g’ old.txt > new.txt заменить все John на Nick
- sed -r ‘s/J[a-z]*n/Nick/g’ old.txt > new.txt заменить все слова, которые начинаются на J и кончаются на n на Nick
- sed -n ‘2,4p’ file.txt вывести строки с 2 по 4
- sed ‘2,4d’ file.txt вывести все строки кроме 2-4
- sed -n ‘/[0-9]\{2\}/p’ file.txt вывести строки с 2 цифрами подряд
- sed '2,/[Rr]ight/d' file.txt вывести все строки кроме со 2 до строки содержащей “right” (с большой или маленькой буквы)

## Права доступа

- users - узнать кто сейчас в системе

- less /etc/passwd  
    syslog&#58;x&#58;100:103::...  
    bi&#58;x&#58;1000:1000:bi,,,...(UID >= 1000) - узнать какие вообще есть пользователи

- groups <имя_пользователя> - узнать группы пользователя

- ls -l <путь> - узнать права доступа
```
ls -l <путь>
drwxrwxr-x 2 user group ... dir
-rw-rw-r-- 1 user group ... file
```
 
- r (100, 4) – Read
- w (010, 2) – Write
- x (001, 1) – eXecute

### Права у файлов
r – просмотр содержимого  
w – редактирование  
x – запуск  

### Права у директорий
r – просмотр содержимого  
w – создание/удаление файлов/поддиректорий  
x – 1) вход в директорию  
    2) просмотр inode файлов/поддиректорий
 
### Изменить права доступа
- chmod [ugoa][+-][rwx] <путь>
```
chmod ug+rw file.txt
```
- chmod [octal code] <путь>
```
chmod 777 file.txt
```

### Изменить обладателя
- chown new_user:new_group <путь>
```
chown zoidberg file.txt
```
```
chown :futurama file.txt
```

### Cуперпользователь
root (группа root)

### Сделать от имени root:
- sudo <действие>
```
sudo mkdir dir
```
```
sudo chmod -r dir
```

### Посчитать что-то в файле:
- wc [что-считаем] <путь>
```
wc -l file.txt
```
```
wc -w file.txt
```
```
wc -c file.txt
```

### Сравнить файлы/директории
- diff [-q -r] <путь1> <путь2>
```
diff file1.txt file2.txt | less
```
```
diff -qr dir1/ dir2/
```

### Узнать сколько места занимаем на диске
- du [--max-depth <глубина> -h] <путь>
```
du -h ~/
```
```
du –-max-depth 1 -h .
```
```
df [-h]
```

### узнать сколько места занято/свободно
- во всей системе

Вывести часть файла:  
head [-n <количество строк>] <путь>  
tail [-n <количество строк>] <путь>  
```
head -n 10 file.txt
```
```
tail -n 50 file.txt | less
```

### Работа с файлами/директориями
можно использовать {имя1,имя2,...}  
mkdir ./{dir1,dir2,dir3}  
touch ~/{file1,file2}.txt

### Вывод с сортировкой:
- ls --sort=[вид сортировки] -l <путь>
```
ls –-sort=size -l ~/
```
```
ls –-sort=time -l .
```

### Перенаправление в один файл
- &> или &>>
```
program &>> both.txt
```

### Перенаправление одного потока в другой
- 2>&1 stderr в stdout
- 1>&2 stdout в stderr

### Перенаправление в никуда и из ниоткуда:
- /dev/null
```
program 2>/dev/null
```
```
cat /dev/null > file.txt
```