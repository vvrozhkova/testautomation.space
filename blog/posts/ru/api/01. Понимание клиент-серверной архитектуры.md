---
title: Понимание клиент-серверной архитектуры
category: api
description: Понимание клиент-серверной архитектуры
tags: ["api"]
icon: "fas fa-bug"
image: "null"
date: 2022-06-23
keywords: "Понимание клиент-серверной архитектуры"
order: 01
links: [
        {
          items: [
           { title: "Понимание клиент-серверной архитектуры", link: "/ponimanie-klient-servernoj-arhitektury/" },
          ]
        }
      ]
---

В клиент серверной архитектуре есть три звена:
- клиент
- сервер
- база данных

Когда мы вводим данные в программу клиент, клиент передает данные на сервер, а сервер перенаправляет его в БД. Клиент может быть web приложением или desktop приложением.

После того как запрос был обработан в БД, поисковый результат возвращается обратно на сервер, а сервер передает его на клиент. Клиент отрисовывает информацию пользователю.

## Клиент
Нужен для пользователя, он отрисовывает байты кода. Отвечает за то чтобы отобразить пользователю нужную информацию и позволить сформировать запрос в удобном интерфейсе, иногда еще провести базовые проверки введенных данных.

## Сервер
На сервере находится основная логика приложения. 

### Почему всю логику нельзя хранить на клиенте?
Можно. Но клиентов у нас может быть много. К нашему приложению могут обращаться с разных компьютеров. И чтобы все работало быстро и не тормозило нужен мощный клиентский компьютер. Поэтому проще заплатить за мощный сервер, который будет эту логику обрабатывать и остальные клиентские машины могут быть слабее. Также если вся логика будет на клиенте то получается что на каждом клиенте будет храниться код который обрабатывает логику а это дублирование кода. И если мы что то исправляем то нам надо вносить изменения на сотни компьютеров. А это дорого, долго и неудобно.

## База данных
Хранилище данных. Его иногда может и не быть. 

Если приложение простое, то данные могут харниться на сервере. Такая архитектура называется двузвенная. Но в таком случае если сервер упадет или перезагрузится, то информация потеряется. Поэтому лучше когда она храниться отдельно. 

Это может быть не база данных, сервер может записывать информацию в файлы. Но тогда программисту нужно будет самому фактически делать самописную базу данных. Опять же для простых приложений можно и так. Но для серьезного продукта лучше иметь отдельную базу данных. 

База данных специально ориентирована на хранение информации для того чтобы можно было быстро и легко по этой информации искать и она обеспечивает сохранность данных. Даже если компьютер выключится все равно наши данные сохранятся. Также повышается надежность приложения, тк в базе могут храниться персональные данные: ФИО, ИНН, Адрес, Телефон и т.д. и не все должны иметь к ним доступ. 

**Недостаток клиент серверной архитектуры**

Если одно звено упало то не работает все приложение.

Чтобы такого не случалось делают кластер серверов. Это значит что работает не один сервер а несколько. Также перед ними добавляют балансировщик, который решает кому отправлять запрос. Когда приходит запрос балансировщик смотрит какой из серверов менее загружен и передает туда запрос. Такое бывает когда приложение высоконагруженное и один сервер с ним просто не справляется. Таким образом в кластере может быть не 2 сервера, а 10, 15 и т.д.

Точно также можно балансировать базу данных, может быть несколько копий баз данных на разных машинах и балансировщик отправляет запрос то к одной бвзе то ко второй.

Такая схема называется **горящий резерв**. Если нам нужно обновить приложение мы отключаем один сервер временно переложив всю нагрузку на оставшийся обновляем один сервер снова его запускаем, гасим второй и обновляем пока нагрузка идет на оставшиеся сервера и т.д. Работа приложения совсем не останавливается. 

И есть схема **холодный резерв**, когда второй сервер является резервной копией на всякий случай и все запросы идут на один сервер, но если с ним что то случилось и он упал тогда балансировщик перенаправляет всю нагрузку на второй сервер. 

Такие схемы помогают нам устранить проблему упало одно звено все отдыхают.

Сервер дороже, у дисков для серверного приложения особые требования по надежности и есть поддержка специфичных функций. 
