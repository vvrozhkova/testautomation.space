---
title: Словари и сортировка подсчётом
description: Словари и сортировка подсчётом
tags: ["algorithms", "java", "алгоритмы"]
icon: "fas fa-code"
image: "null"
date: 2022-07-25
keywords: "java, algorithms, алгоритмы"
order: 05
links: [
        {
          items: [
           { title: "Алгоритмы (курс Яндекс)", link: "/algoritmy-kurs-yandeks/" },
           { title: "Сложность, тестирование, особые случаи", link: "/slozhnost-testirovanie-osobye-sluchai/" },
           { title: "Линейный поиск", link: "/linejnyj-poisk/" },
           { title: "Множества", link: "/mnozhestva/" },
           { title: "Словари и сортировка подсчётом", link: "/slovari-i-sortirovka-podschyotom/" },
           { title: "Префиксные суммы и два указателя", link: "/prefiksnye-summy-i-dva-ukazatelya/" },
           { title: "Бинарный поиск", link: "/binarnyj-poisk/" },
           { title: "Сортировка событий", link: "/sortirovka-sobytij/" },
           { title: "Деревья", link: "/derevya/" }
          ]
        }
      ]
---

## Сортировка подсчетом

Пусть необходимо отсортировать массив из N целых чисел каждое от 0 до K. 

Обычная сортировка займет $O(N logN)$.

Будем считать количество вхождений каждого числа а затем выводить каждое число столько раз сколько оно встречалось. Это займет $O(N+K)$ и $O(K)$ дополнительной памяти.

Интервал значений можно сдвинуть, чтобы он был не от 0 до K, а от минимального до максимального значения в массиве.

Решение

Создаем массив и заполняем его нулями. Каждому числу соответсвует ячейка соответствующего индекса в массиве. 
Когда встречаем число увеличиваем счетчик в соответсвуюзей ячейке на единицу. 

Затем идем по всем допустимым значениям и выводим число столько раз сколько оно встречалось.

```java
public static void countSort(int[] arr) {
    int max = Arrays.stream(arr).max().getAsInt();
    int min = Arrays.stream(arr).min().getAsInt();

    int k = max - min + 1;
    int[] array = new int[k];
    Arrays.fill(array, 0);

    for (int i = 0; i < arr.length; i++) {
        array[arr[i]] +=1;
    }

    int nowPos = 0;
    for (int i = 0; i < array.length; i++) {
        for (int j = 0; j < array[i]; j++) {
            arr[nowPos] = i;
            nowPos+=1;
        }
    }
}
```

### Задача 1

Дано два числа X и Y без ведущих нулей. Необходимо проверить, можно ли получить первое из второго перестановкой цифр.

Посчитаем количество вхождений каждой цифры в каждое из чисел и сравним. Цифры будем постепенно добывать из числа справа с помощью %10 и /10.

Разложим цифры в массивы по аналогии с сортировкой подсчетом и сравним их. 

Сортировка подсчетом уместна когда разница между максимальным и минимальным небольшая.


## Словари

Словарь - он как множество но к каждому ключу приписано значение

Искать по значению в словаре нельзя

Константа в сложности словарей заметно больше чем у массивов поэтому где можно - лучше использовать сортировку подсчетом.

Сортировку подсчетом использовать неразумно если данные разреженные.

### Задача 1

На шахматной доске N x N находится M ладей (ладья бьет клетки на той же горизонтали и вертикали до ближайшей занятой) 
Определите сколько пар ладей бьют друг друга. Ладьи задаются парой чисел I и J, обозначающих координаты клетки.

$1<= N <= 10^9, 0<=M<=2*10^5$.

Решение

Для каждой занятой горизонтали и вертикали будем хранить количество ладей на них. Количество пар в горизонтали (вертикали) равно количество ладей минус 1. Суммируем это количество пар для всех горизонталей и вертикалей.


## Задел под оптимизацию

